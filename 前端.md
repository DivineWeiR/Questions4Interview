# 1.浏览器篇
## 1.1 常用那几种浏览器测试？主流浏览器的内核有哪些？
1. **Trident内核**：代表产品为**Internet Explorer**，又称其为IE内核。Trident（又称为MSHTML），是微软开发的一种排版引擎；
2. **Webkit内核**：代表作品有Safari、Chrome。WebKit是一个开源项目，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示；
3. **Gecko内核**： **Netscape6**开始采用的内核，后来的**Mozilla FireFox** (火狐浏览器) 也采用了该内核，K-Meleon浏览器也是使用这种内核,Gecko是一套开放源代码的、以C++编写的网页排版引擎；
4. **Presto内核**：目前只有**Opera浏览器**采用该内核此外，Presto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。

## 1.2 说说你对浏览器内核的理解？
浏览器内核主要分成两个部分：**渲染引擎**和**JS引擎**。
**渲染引擎**：负责取得网页内容（html，xml和图像等），整理讯息（e.g.css），以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，因此，渲染效果也不同。所有网页浏览器、电子邮件客户端以及需要编辑显示网络内容的应用程序都需要内核。
**JS引擎**：解析和执行JavaScript来实现网页的动态效果，JavaScript的渲染速度越快，动态网页的展示也越快。

## 1.3 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？
1. 浏览器根据请求的URL交给DNS域名解析，找到IP地址；
2. 浏览器根据IP地址向服务器发起TCP连接，三次握手，与服务器建立TCP连接；
   1. 客户端向服务器发送一个建立连接的请求
   2. 服务器接到请求后发送同意连接的信号
   3. 客户端接到同意连接的信号后，再次向服务器发送了确认信号，然后客户端与服务器的连接建立成功
3. 浏览器发送HTTP请求：浏览器根据URL内容生成HTTP请求，请求中包含请求文件的位置、请求文件的方式等等；
4. 服务器处理请求并返回HTTP报文（HTTP响应报文由三部分组成：状态码、响应报头和响应报文）
   1. 服务器接到请求后，根据HTTP请求中的内容来决定如何获取相应的HTML文件；
   2. 服务器将得到的HTML文件发送给浏览器；
   3. 在浏览器还没有完全接收HTML文件时便开始渲染、显示网页；
   4. 在执行HTML中代码时，根据需要，浏览器会继续请求图片、CSS和JavaScript等文件，过程同HTML。
5. 断开连接。

## 1.4 浏览器缓存
1. sessionStorage
优点：可以临时存储，关闭页面标签自动回收，不支持跨页面交互
缺点：只能作为临时存储，不能存储持久化
2. localStorage
优点：用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。
缺点：存在大小限制，IE8以上的IE版本才支持这个属性；目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换
3. cookie
优点：兼容性最好，几乎所有的浏览器都支持
缺点：大小有限制，而且每次发送请求，请求头里会带着cookie一起发过去，现在基本大多数登录的合法性验证都是用cookie验证的
4. userData
优点：出现的时间比sessionStorage要早
缺点：IE专门的存储方式，存储大小有限，单个文件的大小限制是128KB，一个域名下总共可以保存1024KB的文件，文件个数应该没有限制。在受限站点里这两个值分别是64KB和640KB
## 1.5. HTTP
### 1.5.1 HTTP状态码++
1. 以`2xx`开头的都表示请求成功响应
   
| 状态码 | 含义                                                    |
| ------ | ------------------------------------------------------- |
| 200    | 请求成功                                                |
| 204    | 请求处理成功，但是没有资源可以返回                      |
| 206    | 对资源一部分进行响应，由Content-Range指定范围的实体内容 |

2. 以`3xx`开头的都表示需要进行附加操作以完成请求
   
| 状态码 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 301    | 永久性重定向，该状态码表示请求的资源已经重新分配URI，以后应该使用资源现有的URI |
| 302    | 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问 |
| 303    | 该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源 |
| 304    | 该状态码表示客户端发送附带条件的请求时，服务器允许请求访问资源，但未满足条件的情况 |
| 307    | 临时重定向。该状态码与302 Found有着相同的含义                |

3. 以`4xx`的响应结果表明客户端是发生错误的原因所在。

| 状态码 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 400    | 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。 |
| 401    | 该状态码表示发送的请求需要通过有HTTP认证（BASIC认证、DIGEST认证）的认证信息。 |
| 403    | 该状态码表明对请求资源的访问被服务器拒绝了                   |
| 404    | 该状态码表明服务器上无法找到请求的资源                       |

4. 以`5xx`为开头的响应标头都表示服务器本身发生错误。

| 状态码 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 500    | 该状态码表明服务器端在执行请求时发生了错误。                 |
| 503    | 该状态码表明服务器暂时处于超负载状态或正在停机维护，现在无法处理请求 |

### 1.5.2 URL和URI有什么区别？
**URI = Universal Resource Identifier** 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。
**URL = Universal Resource Locator** 统一资源定位符，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol、host、port、path、parameter、anchor。
**URN = Universal Resource Name** 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。

URI 是用来唯一标识资源， URL 提供资源的识别方法并用着各种方法定位资源。

由于互联网上每个文件都有唯一的URL, 所以URL是一种具体的URI， 可以说URL是URI的一种实现方式。

### 1.5.3 HTTP和HTTPS+

#### HTTP

[超文本传输协议](https://baike.baidu.com/item/超文本传输协议/8535513)（HTTP，HyperText Transfer Protocol)是[互联网](https://baike.baidu.com/item/互联网)上应用最为广泛的一种[网络协议](https://baike.baidu.com/item/网络协议/328636)。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。

**HTTP原理**

1. 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。

2. 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。

#### HTTPS

是以安全为目标的 HTTP 通道，是 **HTTP 的安全版**。HTTPS 的安全基础是 **SSL**（Secure Socket Layer，安全套接字层）。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

**HTTPS设计目标：**

1. 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么 。

2. 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。

3. 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 。

#### HTTP 与 HTTPS的区别

1. HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。

2. HTTP 是超文本传输协议，信息是**明文传输**，HTTPS 则是具有安全性的 **SSL 加密传输**协议。

3. HTTP 和 HTTPS 使用的是完全不同的连接方式，用的**端口也不一样**，前者是**80**，后者是**443**。

4. HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

#### HTTPS相对于HTTP的改进

**双向的身份认证**

客户端和服务端在传输数据之前,会通过基于X.509证书对双方进行身份认证 。具体过程如下：

1. 客户端发起 SSL 握手消息给服务端要求连接。

2. 服务端将证书发送给客户端。

3. 客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。

4. 服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的[公钥](https://baike.baidu.com/item/公钥/6447788)，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。

**数据传输的机密性**

客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。

**防止重放攻击**

SSL 使用序列号来保护通讯方免受报文重放攻击。

#### HTTPS的优缺点

**优点**

1. 使用 HTTPS 协议可认证用户和服务器，**确保数据发送**到正确的客户机和服务器。

2. HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议**安全**，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它**大幅增加了中间人攻击的成本**。

**缺点**

1. HTTPS 协议**握手阶段比较费时**，会使页面的加载时间延长近。

2. HTTPS **连接缓存不如 HTTP 高效**，会**增加数据开销**，甚至已有的安全措施也会因此而受到影响。

3. HTTPS 协议的**安全是有范围的**，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。

4. **SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名**，IPv4 资源不可能支撑这个消耗。

5. **成本增加**。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。

6. HTTPS 协议的**加密范围也比较有限**。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。

#### HTTPS握手+

1. 客户端的浏览器向服务器发送请求，并传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。
2. 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端**传送自己的证书**。
3. 客户端利用服务器传过来的信息**验证服务器的合法性**，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 "发行者的数字签名"，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。
4. 用户端**随机产生一个用于通讯的 "对称密码"**，然后用服务器的公钥（服务器的公钥从步骤2中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。
5. 如果**服务器要求客户的身份认证**（在握手过程中为可选），**用户可以建立一个随机数然后对其进行数据签名**，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。
6. 如果**服务器要求客户的身份认证**，**服务器必须检验客户证书和签名随机数的合法性**，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA 是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。
7. **服务器和客户端用相同的对称加密密钥**，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。
8. **客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤7中的主密码为对称密钥**，同时**通知服务器客户端的握手过程结束**。
9.  **服务器向客户端发出信息，指明后面的数据通讯将使用的步骤7中的主密码为对称密钥**，同时**通知客户端服务器端的握手过程结束**。
10. **SSL 的握手部分结束**，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。

![HTTPS握手](https://img-blog.csdn.net/20180709141944471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 1.5.4 HTTP 2.0 新特性

#### 新的二进制帧层(二进制传输)

HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

![http2.0](https://upload-images.jianshu.io/upload_images/5281821-5e2e23de6cbbc698.png?imageMogr2/auto-orient/strip|imageView2/2/w/607/format/webp)

#### 多路复用

在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。

> **流**：已经建立的连接之间双向流动的字节，它能携带一个至多个消息。
> **消息**：一个完整的帧序列，它映射到逻辑的请求和响应消息。
> **帧**：在HTTP/2通信的最小单元。每个桢包括一个帧头，里面有个很小标志，来区别是属于哪个流。

**帧代表着最小的数据单位**，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

所有的通信都建立在一个TCP连接上，可以传递大量的双向流通的流。
每个流都有**独一无二的标志和优先级**。
每个消息都是逻辑上的请求和相应消息。由一个或者多个帧组成。
来自不同流的帧可以通过帧头的标志来关联和组装起来。

**多路复用，就是在一个 TCP 连接中可以存在多条流。**换句话说，**也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求**。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

![http2.0流](https://www.mwcxs.top/static/upload/pics/2019/2/27eEKU9cpx8hlWvTRL-GjzVhIR.png)

#### 流的优先级

为了能方便流的传输顺序,HTTP/2.0提出,使每个流都有一个权重和依赖.

- 每个流的权重值在1~256之间
- 每个流可以详细给出对其他流的依赖

流权重和依赖的结合使客户端可以构造和通信一个优先级二叉树来表达它更想得到哪种响应.然后服务端可以按权重分配硬件资源(CPU,内存)

![HTTP/2 流的优先级](https://upload-images.jianshu.io/upload_images/5281821-a424cc207432cde0.png?imageMogr2/auto-orient/strip|imageView2/2/w/666/format/webp)

在HTTP/2 ,一个流的依赖可以显式用其他流的标志来表达,如果省略了标志,则说明它的依赖是根流.一般来说,父流应该在它的依赖流之前分配资源,例如D应该是C之前被发送.依赖于同一父节点的应该按照他们的权重分配资源.例如A结点的权重为12,它的兄弟结点B的结点的权重为4.然后按比例分资源,A占12/16,B占4/16.如上面所述,流的依赖和权重提供了一种很好的表达式语言来表达资源的优先级.但是我们应该明白,,流的依赖和权重只是提供了一种传输偏好,而不是说一定是这样的比例.

#### header压缩

在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

#### 服务器端push

在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。

可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。

#### QUIC

这是一个谷歌出品的基于 UDP 实现的同为传输层的协议，目标很远大，希望替代 TCP 协议。

1、该协议支持多路复用，虽然 HTTP 2.0 也支持多路复用，但是下层仍是 TCP，因为 TCP 的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞的问题，但是 UDP 没有这个机制

2、实现了自己的加密协议，通过类似 TCP 的 TFO 机制可以实现 0-RTT，当然 TLS 1.3 已经实现了 0-RTT 了

3、支持重传和纠错机制（向前恢复），在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包。**纠错机制**：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包和异或值包算出丢失包。在丢失两个包或以上的情况就使用重传机制，因为算不出来了。

### 1.5.5 HTTP请求方法

1、OPTIONS

返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性

2、HEAD

向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。

3、GET

向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url

4、POST

向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form

5、PUT

向指定资源位置上传其最新内容

6、DELETE

请求服务器删除Request-URL所标识的资源

7、TRACE

回显服务器收到的请求，主要用于测试或诊断

8、CONNECT

HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

#### PUT和POST的区别

PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）

POST请求：后一个请求不会把第一个请求覆盖掉。（所以POST用来增资源）

PUT请求的目的是用来替换整个目标资源。PUT请求具有 **幂等性（idempotent）**。（幂等性的意思在这个RFC的4.2.2里说了“同样的请求，不管发多少次，每次服务器处理完之后的结果，都和只发一次是一样的。”

（缓存性，POST是可以被缓存的，PUT却不行。？）

### 1.5.6 HTTP缓存

Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。

浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。这里我们只讨论 HTTP 缓存相关内容。

# 2.HTML篇

## 2.1 Doctype
`<!DOCTYPE>`声明位于位于HTML文档中的第一行，处于`<html>`标签之前。

### 2.1.1 作用
告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE**不存在或格式不正确**会导致文档以**兼容模式**呈现。

### 2.1.2 标准模式和兼容模式各有什么区别
标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。
在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。
简单的说，就是尽可能的显示能显示的东西给用户看。

**具体的说：**

1. **width不同**
   在严格模式中 ：width是内容宽度 ，元素真正的宽度 = margin-left + border-left-width + padding-left + width + padding-right + border-right- width + margin-right;
   在兼容模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( padding-left + padding-right + border-left-width + border-right-width)

2. 兼容模式下可设置**百分比的高度和行内元素的高宽**
     在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。
     在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。

3. 用margin:0 auto设置水平居中在IE下会失效
     使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决）
     body{text-align:center};#content{text-align:left}

4. 兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效

### 2.1.3 为什么H5只需要写\<!DOCTYPE>

- HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）
- 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型

### 2.1.4 常见的DOCTYPE 声明

**HTML 5**

```html
<!DOCTYPE html>
```

**HTML 4.01 Strict**
该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

**HTML 4.01 Transitional**
该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
```

**HTML 4.01 Frameset**
该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN""http://www.w3.org/TR/html4/frameset.dtd">
```

**XHTML 1.0 Strict**

该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

**XHTML 1.0 Transitional**

该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

**XHTML 1.0 Frameset**

该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
```

**XHTML 1.1**

该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
```

## 2.2 说说你对语义化的理解？

### 2.2.1 什么是HTML语义化？

根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。

### 2.2.2 为什么要语义化

1. 为了在没有CSS的情况下，页面也能呈现出很好地内容结构及代码结构；
2. 利于SEO搜索引擎优化，和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重；
3. 方便浏览器和其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
4. 提高代码的可维护和可重用性。

### 2.2.3 语义化注意事项

1. 尽可能**少的使用**无语义的标签**div和span**；
2. 在语义不明显时，**既可以使用div或者p时，尽量用p**, 因为p在默认情况下有**上下间距**，对兼容特殊终端有利；
3. **不要使用纯样式标签**，如：b、font、u等，改用css设置。
4. 需要**强调的文本，可以包含在strong或者em标签中**（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；
5. 使用**表格时，标题要用caption，表头用thead，主体部分用tbody包围**，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；
6. **表单域要用fieldset**标签包起来，并用**legend标签说明表单的用途**；
7. **每个input标签对应的说明文本都需要使用label标签**，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。

## 2.3 HTML与XHTML有什么区别?

**最主要的不同：**

- XHTML 元素必须被正确地嵌套。
- XHTML 元素必须被关闭。
- 标签名必须用小写字母。
- XHTML 文档必须拥有根元素。
- XHTML对于图片需添加alt属性

## 2.4 页面导入样式时，使用link和@import有什么区别？

### 2.4.1 import的写法

```
\<style type=”text/css”>
	@import url（“a.css”）；
\</style>
```

### 2.4.2 link的写法

```
\<link rel="stylesheet" href="index.css">
```

### 2.4.3 两者区别

1. **来源**：link属于XHTML标签，import是CSS提供的方式。**link方式除了CSS，还可以定义RSS，定义rel连接属性等，而import只能加载CSS**。
2. **顺序**：**link是页面加载时同时执行的，而import是在页面加载完之后，才会执行的**（所以容易导致样式闪烁，即开始页面没有样式，突然会闪烁一下，然后就有了样式，就我个人比较喜欢link引用的方式）
3. **js控制的差别**：当页面需要使用javascript控制dom改变样式的时候，只能使用link标签，因为import不是js操作dom可以控制的。也不支持js操作dom来控制。

## 2.5 HTML5有哪些新特性？+

1. 语义化标签
2. 增强型表单
3. 新增视频<video>和音频<audio>标签
4. Canvas&SVG绘图
5. 地理定位API
6. 拖放API
7. Web Worker
8. Web Storage
9. WebSocket

### 2.5.1 h5新语义/结构元素

| 标签          | 描述                                                 |
| :------------ | :--------------------------------------------------- |
| \<article>    | 定义文档内的文章。                                   |
| \<aside>      | 定义页面内容之外的内容。                             |
| \<bdi>        | 定义与其他文本不同的文本方向。                       |
| \<details>    | 定义用户可查看或隐藏的额外细节。                     |
| \<dialog>     | 定义对话框或窗口。                                   |
| \<figcaption> | 定义 \<figure> 元素的标题。                          |
| \<figure>     | 定义自包含内容，比如图示、图表、照片、代码清单等等。 |
| \<footer>     | 定义文档或节的页脚。                                 |
| \<header>     | 定义文档或节的页眉。                                 |
| \<hgroup>     | 用于对网页或区段（section）的标题进行组合。          |
| \<main>       | 定义文档的主内容。                                   |
| \<mark>       | 定义重要或强调的内容。                               |
| \<menuitem>   | 定义用户能够从弹出菜单调用的命令/菜单项目。          |
| \<meter>      | 定义已知范围（尺度）内的标量测量。                   |
| \<nav>        | 定义文档内的导航链接。                               |
| \<progress>   | 定义任务进度。                                       |
| \<rp>         | 定义在不支持 ruby 注释的浏览器中显示什么。           |
| \<rt>         | 定义关于字符的解释/发音（用于东亚字体）。            |
| \<ruby>       | 定义 ruby 注释（用于东亚字体）。                     |
| \<section>    | 定义文档中的节。                                     |
| \<summary>    | 定义 \<details> 元素的可见标题。                     |
| \<time>       | 定义日期/时间。                                      |
| \<wbr\>       | 定义可能的折行（line-break）。                       |

总体来说，这些标签就是div标签的语义化转化，过去我们曾用div来包裹某个块或者说组件，现在h5使用这些标签实现语义化，有利于代码可读性和SEO。语义元素在IE6-8的兼容可以使用。

#### H5删除的元素

| 删除的元素                                                   | 替代方法        |
| ------------------------------------------------------------ | --------------- |
| <acronym> 首字母缩写                                         | <abbr>          |
| <applet>                                                     | <object>        |
| <basefont> 页面上默认字体颜色和字号                          | css             |
| <big> 更大的文本                                             | css             |
| <center> 文本水平居中                                        | css             |
| <dir> 目录列表                                               | css             |
| <font> 字体外观，尺寸，颜色                                  | css             |
| <frame> 定义子窗口                                           |                 |
| <frameset> 定义框架集                                        |                 |
| <noframes> 向浏览器显示无法处理框架的提示文本，位于frameset元素中 |                 |
| <strike> 文本添加删除线                                      | css或<s>或<del> |
| <tt> 定义打字机文本                                          | css             |



### 2.5.2 增强型input

#### 新增表单元素

| 标签        | 描述                             |
| :---------- | :------------------------------- |
| \<datalist> | 定义输入控件的预定义选项。       |
| \<keygen>   | 定义键对生成器字段（用于表单）。 |
| \<output>   | 定义计算结果。                   |



#### 新增输入类型和输入属性

| 新的输入类型   | 说明                                                         | 新的输入属性     | 说明                                                         |
| -------------- | ------------------------------------------------------------ | ---------------- | ------------------------------------------------------------ |
| color          | 用于应该包含颜色的输入字段。（颜色选择器）                   | autocomplete     | 属性规定表单或输入字段是否应该自动完成。（on\|off）          |
| date           | 用于应该包含日期的输入字段。                                 | autofocus        | 规定当页面加载时 \<input> 元素应该自动获得焦点。             |
| datetime       | 允许用户选择日期和时间（有时区）。(Chrome、FF、IE不支持)     | form             | 规定 \<input> 元素所属的一个或多个表单。 （空格分隔）        |
| datetime-local | 允许用户选择日期和时间（无时区）。（FF、IE不支持）           | formaction       | 规定当提交表单时处理该输入控件的文件的 URL。                 |
| email          | 用于应该包含电子邮件地址的输入字段。                         | formenctype      | 规定当把表单数据（form-data）提交至服务器时如何对其进行编码（仅针对 method="post" 的表单）。 |
| month          | 允许用户选择**月份和年份**。                                 | formmethod       | 定义用以向 action URL 发送表单数据（form-data）的 HTTP 方法。 |
| number         | 用于应该包含数字值的输入字段。                               | formnovalidate   | 规定在提交表单时不对 \<input> 元素进行验证。【额外提交】     |
| range          | 用于应该包含一定范围内的值的输入字段。（部分浏览器显示为滑块） | formtarget       | 规定的名称或关键词指示提交表单后在何处显示接收到的响应。     |
| search         | 用于搜索字段（搜索字段的表现类似常规文本字段）。             | height&width     | 规定 \<input> 元素的高度和宽度。                             |
| tel            | 用于应该包含电话号码的输入字段。（只有 Safari 8 支持 tel 类型。） | list             | list 属性引用的 \<datalist> 元素中包含了 \<input> 元素的预定义选项。 |
| time           | 允许用户选择时间（无时区）。                                 | min&max          | 规定 \<input> 元素的最小值和最大值。                         |
| url            | 用于应该包含 URL 地址的输入字段。自动验证。（IE9及之前不支持） | multiple         | 规定允许用户在 \<input> 元素中输入一个以上的值。             |
| week           | 允许用户选择周和年。                                         | novalidate       | 规定在提交表单时不对表单数据进行验证。                       |
|                |                                                              | pattern (regexp) | 规定用于检查 \<input> 元素值的正则表达式。                   |
|                |                                                              | placeholder      | 规定用以描述输入字段预期值的提示（样本值或有关格式的简短描述）。 |
|                |                                                              | required         | 规定在提交表单之前必须填写输入字段。                         |
|                |                                                              | step             | 规定 \<input> 元素的合法数字间隔。                           |



### 2.5.3 新增视频\<video>和音频\<audio>标签

| **标签**     | **描述**                                               |
| :----------- | :----------------------------------------------------- |
| **\<audio>** | 定义声音或音乐内容。                                   |
| <embed>      | 定义外部应用程序的容器（比如插件）。                   |
| <source>     | 定义 <video> 和 <audio> 的来源。                       |
| <track>      | 定义 <video> 和 <audio> 的轨道。（主流浏览器都不支持） |
| **\<video>** | 定义视频或影片内容。                                   |



### 2.5.4 新的图形标签

| 标签     | 描述                             |
| :------- | :------------------------------- |
| <canvas> | 定义使用 JavaScript 的图像绘制。 |
| <svg>    | 定义使用 SVG 的图像绘制。        |



#### SVG和Canvas的区别

- SVG 是一种使用 XML 描述 2D 图形的语言。

- Canvas 通过 JavaScript 来绘制 2D 图形。

- SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。

- 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

- Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。



### 2.5.5 地理定位

```pseudocode
window.navigator.geolocation {
    getCurrentPosition:  fn  用于获取当前的位置数据
    watchPosition: fn  监视用户位置的改变
    clearWatch: fn  清除定位监视
}
```



### 2.5.6 拖放API

**拖动的源对象(source)可能触发的事件：**

- dragstart：拖动开始

- drag：拖动中

- dragend：拖动结束

**拖动的目标对象(target)可能触发的事件：**

- dragenter：拖动进入

- dragover：拖动悬停

- drop：松手释放

- dragleave：拖动离开

拖放API事件句柄中所有的事件对象都有一个dataTransfer属性（数据运输对象），用于在源对象和目标对象间传递数据。

**源对象**：event.dataTransfer.setData(key, value)

**目标对象**：var value = event.dataTransfer.getData(key)



### 2.5.7 WebWorker

Chrome浏览器中发起资源请求的有6个线程；但是只有1个线程负责渲染页面——称为UI主线程——浏览器中所有的代码只能由一个线程来执行。若浏览器加载了一个很耗时的JS文件(可能影响DOM树结构)，浏览器必须等待该文件执行完成才会继续执行后续的代码。执行耗时JS任务过程中，会暂停页面中一切内容的渲染以及事件的处理。



**Worker的本质**：就是一个执行指定任务的独立线程；且该线程可以与UI主线程进行消息数据传递。

**HTML文件中：**

```js
var w = new Worker('js/x.js')
w.postMessage('发送给Worker线程的消息');
w.onmessage = function(e){
	e.data; //来自Worker线程的消息
}
```

**JS文件中：**

```js
onmessage = function(e){
	var data = e.data;  //接收UI线程的消息
	//执行耗时任务....
	postMessage(result);  //给UI线程发送消息
}
```

**注意：**Worker任务不允许直接操作DOM树，也不允许使用任何的BOM对象！需要的数据只能由UI主线程来传递，处理的结果也必须交由UI线程来显示。



### 2.5.8 WebStorage

#### Web存储结构

1. **服务器端存储**
   1. 数据库存储，如商品、用户等核心数据
   2. Session/内存存储，如用户的登录信息
2. 客户端存储
   1. Cookie存储，如用户偏好、访问历史，浏览器兼容性好但处理麻烦且容量限制
   2. H5 WebStorage存储，如用户偏好、访问历史等安全要求的数据，老IE不兼容但易使用且容量大

#### H5中的WebStorage

1. sessionStorage：类数组对象，通过key=>value对存储字符串数据——会话级存储
2. localStorage：类数组对象，通过key=>value对存储字符串数据——本地/跨会话级/永久存储

#### cookies、sessionStorage、localStora的区别

| 不同点         | 存储大小 | 有效时间                                                     | 数据与服务器交互方式                                         |
| -------------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| cookies        | <=4K     | 在设置cookie过期之前一直有效（无论窗口浏览器是否关闭）       | 正常情况下，cookies数据会自动传到服务器，服务器也可以写cookie到客户端 |
| sessionstorage | 5M       | 数据在当前浏览器关闭后删除（sessionStorage与存储数据的顶级窗口或浏览器选项卡具有相同的生命周期。） | 不会发送数据到服务端                                         |
| localstorage   | 5M       | 持久存储，浏览器关闭后不会丢失除非主动删除（直到Web应用程序删除它或用户要求浏览器删除它） | 不会发送数据到服务端                                         |

### 2.5.9 WebSocket

WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。

WebSocket 使得客户端和服务器之间的数据交换变得更加简单，**允许服务端主动向客户端推送数据**。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

## 2.6 iframe的优缺点？

### 2.6.1 优点

1. 能顾原封不动地把嵌入的网页展现出来；
2. 如果有多个网页引用iframe，那么仅需修改iframe的内容，就可以实现调用的每一个页面内容的修改，方便快捷；
3. 网页如果为了统一风格，头部和版本都一样，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用性；
4. 吐过遇到加载缓慢的第三方内容如图标和广告，那么可以由iframe来解决。

### 2.6.2 缺点

1. 会产生很多页面，不容易管理；
2. iframe框架结构有时会让人感到迷惑，如果框架个数多，可能会出现多个上下、左右滚动条，会分散访问者的注意力，用户体验差；
3. 代码复杂，无法被一些搜素引擎索引到，不能被搜索引擎爬虫处理，不利于SEO。
4. 很多移动设备无法完全显示框架，设备兼容性差。
5. iframe框架会增加服务器的http请求，对于大型网站来说不可取。

## 2.7 img中的alt与title属性 

**alt：**在图片无法正确显示的时候起到文本替代的作用

**title：**鼠标滑过时显示的文字提示



# 3. CSS篇

## 3.1 行内元素有哪些？块级元素有哪些？

### 3.1.1 行内元素

- 和其他元素都在一行上；
- 高，行高及外边距和内边距不可改变；
- 宽度就是它的文字或图片的宽度，不可改变；
- 内联元素只能容纳文本或者其他内联元素；
- 对行内元素，需要注意如下：
  - 设置宽度width 无效。
  - 设置高度height 无效，可以通过line-height来设置。
  - 设置margin 只有左右margin有效，上下无效。
  - 设置padding 只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。

**常见行内元素**

| 标签               | 描述                       |
| :----------------- | :------------------------- |
| <a>                | 定义锚。                   |
| <audio>            | 定义音频。                 |
| \<br>              | 定义简单的折行。           |
| <button>           | 定义按钮 (push button)。   |
| <code>             | 定义计算机代码文本。       |
| <i>                | 定义斜体字。               |
| <img>              | 定义图像。                 |
| <input>            | 定义输入控件。             |
| <label>            | 定义 input 元素的标注。    |
| <select>           | 定义选择列表（下拉列表）。 |
| <span>             | 定义文档中的节。           |
| <textarea>         | 定义多行的文本输入控件。   |
| <video>            | 定义视频。                 |
| 其他和文本相关标签 |                            |

### 3.1.2 块级元素

- 总是在新行上开始；
- 高度，行高以及外边距和内边距都可控制；
- 宽度缺省是它的容器的100%，除非设定一个宽度。
- 它可以容纳内联元素和其他块元素

| 标签         | 描述                                       |
| :----------- | :----------------------------------------- |
| <article>    | 定义文章。                                 |
| <aside>      | 定义页面内容之外的内容。                   |
| <canvas>     | 定义图形。                                 |
| <caption>    | 定义表格标题。                             |
| <dd>         | 定义定义列表中项目的描述。                 |
| <div>        | 定义文档中的节。                           |
| <dl>         | 定义定义列表。                             |
| <dt>         | 定义定义列表中的项目。                     |
| <details>    | 定义元素的细节。                           |
| <fieldset>   | 定义围绕表单中元素的边框。                 |
| <figcaption> | 定义 figure 元素的标题。                   |
| <figure>     | 定义媒介内容的分组，以及它们的标题。       |
| <footer>     | 定义 section 或 page 的页脚。              |
| <form>       | 定义供用户输入的 HTML 表单。               |
| <h1> to <h6> | 定义 HTML 标题。                           |
| <header>     | 定义 section 或 page 的页眉。              |
| <hr>         | 定义水平线。                               |
| <legend>     | 定义 fieldset 元素的标题。                 |
| <li>         | 定义列表的项目。                           |
| <menu>       | 定义命令的列表或菜单。                     |
| <meter>      | 定义预定义范围内的度量。                   |
| <nav>        | 定义导航链接。                             |
| <noframes>   | 定义针对不支持框架的用户的替代内容。       |
| <noscript>   | 定义针对不支持客户端脚本的用户的替代内容。 |
| <ol>         | 定义有序列表。                             |
| <output>     | 定义输出的一些类型。                       |
| <p>          | 定义段落。                                 |
| <pre>        | 定义预格式文本。                           |
| <section>    | 定义 section。                             |
| <table>      | 定义表格。                                 |
| <tbody>      | 定义表格中的主体内容。                     |
| <td>         | 定义表格中的单元。                         |
| <tfoot>      | 定义表格中的表注内容（脚注）。             |
| <th>         | 定义表格中的表头单元格。                   |
| <thead>      | 定义表格中的表头内容。                     |
| <time>       | 定义日期/时间。                            |
| <tr>         | 定义表格中的行。                           |
| <ul>         | 定义无序列表。                             |

## 3.2 CSS盒模型

所有HTML元素可以看作盒子，在CSS中，"box model"这一术语是用来设计和布局时使用。CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：**边距，边框，填充，和实际内容**。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。
下面的图片说明了盒子模型(Box Model)：

![CSS盒模型](https://images2018.cnblogs.com/blog/1355903/201805/1355903-20180503195326308-1458795751.png)

盒模型分为两种：**W3c标准的盒子模型（标准盒模型【content-box】）** 、第二种**IE标准的盒子模型（怪异盒模型【border-box】）**

**标准盒模型盒子大小=**content+border+padding+margin

**怪异盒模型盒子大小=****width(content + border + padding) + margin

![标准盒模型](https://img2018.cnblogs.com/blog/1748092/201908/1748092-20190809145641572-714793117.jpg)

![IE盒模型](https://img2018.cnblogs.com/blog/1748092/201908/1748092-20190809145529154-1986045519.jpg)

定义了完整的doctype的标准文档类型，无论是哪种模型情况，最终都会触发标准模式，如果doctype协议缺失，会由浏览器自己界定，在IE浏览器中IE9以下（IE6.IE7.IE8）的版本触发怪异模式，其他浏览器中会默认为W3c标准模式。

**通过属性box-sizing来设置盒子模型的解析模式**

**content-box**： **默认值**，border和padding不算到width范围内，可以理解为是W3c的标准模型(default)

**border-box**：border和padding划归到width范围内，可以理解为是IE的怪异盒模型

**padding-box：**将padding算入width范围

## 3.3 CSS浮动

### 3.3.1 产生原因及现象

一个盒子设置了float属性，导致父级对象盒子不能被撑开。

### 3.3.2 浮动产生的副作用

1. **背景不能显示**：由于浮动产生，如果对父级设置了background，而父级不能被撑开，所以导致背景不能显示。

2. **边框不能撑开**
3. **margin、padding设置值不能正确显示**

### 3.3.3 清除浮动的方式

1. **父级元素定义height**
   原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。
   优点：简单，代码少，容易掌握
   缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题
   建议：不推荐使用，只建议高度固定的布局时使用
   评分：★★☆☆☆
2. **结尾处加空div标签 clear:both**
   原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度
   优点：简单，代码少，浏览器支持好，不容易出现怪问题
   缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不爽
   建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法
   评分：★★★☆☆
3. **父级div定义 伪类:after 和 zoom**
   原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题
   优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）
   缺点：代码多，不少初学者不理解原理，要两句代码结合使用，才能让主流浏览器都支持。
   建议：推荐使用，建议定义公共类，以减少CSS代码。
   评分：★★★★☆
4. **父级div定义 overflow:hidden**
   原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度
   优点：简单，代码少，浏览器支持好
   缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。
   建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。
   评分：★★★☆☆
5. **父级div定义 overflow:auto**
   原理：同4，使用overflow:auto时，浏览器会自动检查浮动区域的高度。
   优点：简单，代码少，浏览器支持好。
   缺点：内部宽高超过父级div时，会出现滚动条。
   建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。

## 3.4 CSS选择符都有哪些？哪些属性可以继承？优先级算法如何计算？

### 3.4.1 选择符有哪些？

#### 通配选择符

\* :{} 匹配所有的元素

#### 类型选择符

p:{} 匹配指定HTML元素

#### 属性选择符

1. input[attr] 选择具有某个属性的元素。

2. input[attr=value] 选择等于具体属性值的元素。

3. input[attr~=value] 根据属性值中的词列表的某个词进行选择。

4. input[attr^="value"] 子串匹配。以value开头。

5. input[attr$="value"] 子串匹配。以value结尾。

6. input[attr*="value"] 子串匹配。包含value。

7. input[attr|=value] 特定属性选择类型。常用于匹配语言。

   ```html
   <style>
   	*[lang|="en"] {color: red;}
   </style>
   <p lang="en">Hello!</p> <!--可以匹配-->
   <p lang="en-us">Greetings!</p> <!--可以匹配-->
   <p lang="en-au">G'day!</p> <!--可以匹配-->
   <p lang="fr">Bonjour!</p> <!--无法匹配-->
   <p lang="cy-en">Jrooana!</p> <!--无法匹配-->
   ```

### 3.4.2 哪些属性可以继承

#### 字体系列属性

**font、font-family、font-weight、font-size、font-style**、font-variant、font-stretch、font-size-adjust

#### 文本系列属性

**color、text-align、line-height**、text-indent、word-spacing、letter-spacing、text-transform、direction

#### 元素可见性

visibility

#### 表格布局属性

caption-side、border-collapse、border-spacing、empty-cells、table-layout

#### 列表属性

list-style-type、list-style-image、list-style-position、list-style

#### 生成内容属性

quotes

#### 光标属性

cursor

#### 页面样式属性

page、page-break-inside、windows、orphans

#### 声音样式属性

speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、azimuth、elevation

## 3.5 CSS3新增伪类有哪些？

1. `:nth-child(n)`选择父元素下的第n个子元素。n可以接受具体的数值，也可以接受函数（如4n-1）。需要注意的是，n是从1开始计算，而不是0。当函数中的n系数为负时，甚至可以达到选择前n个元素的效果。n为odd和even选择奇数偶数元素。

2. `:nth-last-child`倒数计算。

3. `:last-child`最后一个元素。

4. `:only-child`其父元素的唯一元素。

5. `:nth-of-type(n)`父元素下第n个elem元素，n接受的格式和nth-child一样。甚至在绝大多数情况下，nth-of-type的效果甚至和nth-child没有区别，那这两个伪类到底是什么区别呢。

   elem:nth-of-type(n)是“选择父元素下第n个elem元素”。

   而elem:nth-child(n)是“这个伪类选中父元素下的第n个子元素，并且这个子元素的标签名为elem”。

6. `elem:first-of-type`和`elem:last-of-type`选中父元素下第1个/最后一个elem元素。
7. `elem:only-of-type`唯一的elem元素
8. `elem:empty`选择不包含子元素和内容的elem标签。
9. `elem:enabled`和`elem:disabled`可用、禁用状态
10. `elem:checked`匹配每个选中的input元素（适用于单选框和复选框）

## 3.6 如何居中div？

```html
<div id="father">
    <div id="son">
    </div>
</div>
```

### 3.6.1 div行内元素 text-align: center(仅水平)

```css
.father{
    text-align:center;
}

.son{
    display:inline-block;
}
```

### 3.6.2 div块级元素 margin: 0 auto（仅水平）

```css
.son{
    margin:0 auto;
    display:blck;
}
```

### 3.6.3 脱离文档流 绝对定位（水平垂直）

```css
.father{
    position: relative;
}

.son{
    position: absolute;
    top: 50%;
    left: 50%;
    
    width: 10em;
    height: 10em;
    
    margin-top: -5em;
    margin-left: -5em;
}
```

使用calc简化

```css
.son{
    position: absolute;
    top: calc(50% - 5em);
    left: calc(50% - 5em);
    width: 10em;
    height: 10em;
}
```

### 3.6.4 transform变形 （水平垂直）

```css
.son{
    position: absolute;
    top:50%;
    left:50%;
    
    transform: translate(-50%,-50%);
}
```

#### 基于flex布局，全屏（水平垂直）

```css
.father{
    display:flex;
    min-height:100vh;
}
```

#### 基于flex布局，父元素有宽高

```css
.father{
    display:flex;
    align-items:center;
    justfy-content:center;
}
```



## 3.7 为什么要初始化CSS?

1. **浏览器差异**

   因为不同浏览器对标签的默认值不同，如果没对css初始化会出现浏览器之间的页面显示差异

2. **提高编码质量**

   如果不初始化，整个页面做完会很糟糕，重复的css样式很多

## 3.8 说说你对BFC规范的理解？

### 3.8.1 何为BFC

在一个Web页面的CSS渲染中，块级格式化上下文 (Block Fromatting Context)是按照块级盒子布局的。W3C对BFC的定义如下：

浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）

### 3.8.2 创建BFC

- float的值不是none
- position 的值不是static或者relative
- display的值是inline-block,table-cell,flex,table-caption或者inline-flex
- overflow的值不是visible

### 3.8.3 BFC的特性

- 内部的盒子会在垂直方向上一个接一个放置
- 于同一个BFC的两个相邻盒子的margin会重叠
- 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此
- BFC的区域不会与float的元素区域重叠
- 计算BFC的高度时，浮动子元素也参与计算
- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然

### 3.8.4 BFC在布局中的应用

- 要阻止margin重叠，只要将俩个元素放在不同BFC中即可
- 使得父元素包含子元素，常见的方式是为父元素设置overflow：hidden或者浮动父元素。根本原因在于创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题
- 与浮动元素相邻的已生成BFC的元素不能与浮动元素互相覆盖。利用该特性可以作为多栏布局的一种实现方式. 特点在于左右俩栏的宽度固定，中间栏可以根据浏览器宽度自适应

## 3.9 讲讲 position float display 各有哪些取值，它们互相之间会如何影响？

### 3.9.1 position的取值

static(默认)、relative、absolute、fixed、inherit

#### static

始终处于文档流给予的位置。看起来好像没有用，但它可以快速取消定位，让top，right，bottom，left的值失效。在切换的时候可以尝试这个方法。z-index无效（其他才有效)

#### relative和absolute

relative和absolute都可以用于定位，区别在于前者的div还属于正常的文档流，后者已经是脱离了正常文档流，不占据空间位置，不会将父类撑开。定位原点relative是相对于它在正常流中的默认位置偏移，它原本占据的空间仍然保留；absolute相对于第一个position属性值不为static的父类。所以设置了position：absolute，其父类的该属性值要注意，而且overflow：hidden也不能乱设置，因为不属于正常文档流，不会占据父类的高度，也就不会有滚动条。

#### fixed

fixed旧版本IE不支持，却是很有用，定位原点相对于浏览器窗口，而且不能变。常用于header，footer，或者一些固定的悬浮div，随滚动条滚动又稳定又流畅，比JS好多了。fixed可以有很多创造性的布局和作用，兼容性是问题。

#### inherit

position：inherit。规定从父类继承position属性的值，所以这个属性也是有继承性的。IE不支持。

### 3.9.2 float的取值

none（默认）、left、right、inherit。

float：left(或right)，向左（或右）浮动，直到它的边缘碰到包含框或另一个浮动框为止。且脱离普通的文档流，会被正常文档流内的块框忽略。不占据空间，无法将父类元素撑开。

任何元素都可以浮动，浮动元素会生成一个块级框，不论它本身是何种元素。因此，没有必要为浮动元素设置display：block。

如果浮动非替换元素，则要指定一个明确的width，否则它们会尽可能的窄。（什么叫替换元素？根据元素本身的特点定义的， (X)HTML中的img、input、textarea、select、object都是替换元素，这些元素都没有实际的内容。 (X)HTML的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。）

### 3.9.3 position的取值

**none** | **inline** | **block** | **list-item** | **inline-block** | **table** | **inline-table** | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group |run-in |box | inline-box | flexbox | inline-flexbox | **flex** | inline-flex | **gird** | inline-grid | **inherit**

**`none：`隐藏对象。与`visibility`属性的`hidden`值不同，其不为被隐藏的对象保留其物理空间**
**`inline`：指定对象为内联元素。**
**`block`：指定对象为块元素。**
**`list-item`：指定对象为列表项目。**
**`inline-block`：指定对象为内联块元素。（CSS2）**
**`table`：指定对象作为块元素级的表格。类同于html标签`<table>`（CSS2）**
`inline-table`：指定对象作为内联元素级的表格。类同于html标签`<table>`（CSS2）
`table-caption`：指定对象作为表格标题。类同于html标签`<caption>`（CSS2）
`table-cell`：指定对象作为表格单元格。类同于html标签`<td>`（CSS2）
`table-row`：指定对象作为表格行。类同于html标签`<tr>`（CSS2）
`table-row-group`：指定对象作为表格行组。类同于html标签`<tbody>`（CSS2）
`table-column`：指定对象作为表格列。类同于html标签`<col>`（CSS2）
`table-column-group`：指定对象作为表格列组显示。类同于html标签`<colgroup>`（CSS2）
`table-header-group`：指定对象作为表格标题组。类同于html标签`<thead>`（CSS2）
`table-footer-group`：指定对象作为表格脚注组。类同于html标签`<tfoot>`（CSS2）
`run-in`：根据上下文决定对象是内联对象还是块级对象。（CSS3）
`box`：将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）
`inline-box`：将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）
`flexbox`：将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）
`inline-flexbox`：将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）
**`flex`：将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）**
`inline-flex`：将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）
**`grid`：将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局（CSS3）**

### 3.9.4 相互影响

![img](http://img.blog.csdn.net/20170605112137698)

## 3.10 CSS绘制三角形+

### 3.10.1 border实现

![triangle](https://www.mwcxs.top/static/upload/pics/2019/3/29UWmsYL8T8oUqP3A5RBQc7Wf4.png)

```css
#triangle{
    width: 0;
    height: 0;
    border-left:50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
}
```

### 3.10.2 clip-path实现

```css
#triangle{
    width:100px;
    height:100px;
    background: red;
    clip-path:polygon(0,100%,50%,0,100%,100%);
}
```



## 3.11 隐藏元素的八种方法

- visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在
- opacity: 0; CSS3属性，设置0可以使一个元素完全透明
- position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外
- display: none; 元素会变得不可见，并且不会再占用文档的空间。
- transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留
- `<div hidden="hidden">` HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态
- height: 0; 将元素高度设为 0 ，并消除边框
- filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中

## 3.12 flex是哪几个属性的缩写

flex: ***flex-grow* *flex-shrink* *flex-basis***|auto|initial|inherit;

| 值            | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| *flex-grow*   | 一个数字，规定项目将相对于其他灵活的项目进行扩展的量。       |
| *flex-shrink* | 一个数字，规定项目将相对于其他灵活的项目进行收缩的量。       |
| *flex-basis*  | 项目的长度。合法值："auto"、"inherit" 或一个后跟 "%"、"px"、"em" 或任何其他长度单位的数字。 |
| auto          | 与 1 1 auto 相同。                                           |
| none          | 与 0 0 auto 相同。                                           |
| initial       | 设置该属性为它的默认值，即为 0 1 auto。请参阅 [*initial*](https://www.runoob.com/cssref/css-initial.html)。 |
| inherit       | 从父元素继承该属性。请参阅 [*inherit*](https://www.runoob.com/cssref/css-inherit.html)。 |

# 4. JS篇
## 4.1 面向对象

### 4.1.1 es5的方法与es6的方法对比

```js
//es5
function Person(name) {
     //构造函数里面的方法和属性
    this._name = name;
    this.getName = function () {
         console.log(this._name);
     };
     this.setName = function (name) {
         this._name = name;
     };
 }
 
 let p = new Person("张三");
 p.getName();  // 张三
 p.setName("李四");
 p.getName();  // 李四
```

```js
//es6
// 定义类
class Person {
     //类的构造函数，实例化的时候执行，new的时候执行
     constructor(name) {
         this._name = name;
     }
     getName() {
         console.log(this._name);
     }
     setName(name) {
        this._name = name
    }
}
 let p = new Preson('张三')
 p.getName();  // 张三
 p.setName('李四');
 p.getName();  // 李四
```

### 4.1.2 面向对象的三大特征

#### 封装

我们平时所用的方法和类都是一种封装，当我们在项目开发中，遇到一段功能的代码在好多地方重复使用的时候，我们可以把他单独封装成一个功能的方法，这样在我们需要使用的地方直接调用就可以了。

#### 继承

继承在我们的项目开发中主要使用为子类继承父类。

**es6继承**

```js
class Father {
    constructor(name) {
        this._name = name;
    }　　　//实例方法，通过实例对象调用
    getName() {
        console.log(this._name);
    }
　　// 静态方法不会被继承,并且是通过类名去调用的　　　
    static hitXiaoMing() {
        console.log("打小明")
    }
}
 
class Son extends Father {
    constructor(name, age) {
        //实例化子类的时候把子类的数据传给父类（这里的super必须有，super里的参数是所继承的父类实例化所需要的数据）
        super(name);
        this._age = age;
    } 
}
 
var DaMing = new Father('大明');
Father.hitXiaoMing(); //打小明 
DaMing.getName(); //大明 
var XiaoMing = new Son('小明'，15);
XiaoMing.getName(); //小明
```

#### 多态

多态的具体表现为方法重载和方法重写：

方法重载：重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数

方法重写：重写（也叫覆盖）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样

```js
class Father {
　　　constructor(name) {
         this._name = name;
     }
　　　//实例方法，通过实例对象调用
     getName() {
         console.log(this._name);
     }     work() {     　　console.log('我的工作是累死累活，赚钱养家')     }
　　　// 静态方法不会被继承,并且是通过类名去调用的
　　　static hitXiaoMing() {
         console.log("打小明")
     }
 }
 
 class Son extends Father {
     constructor(name, age) {
         //实例化子类的时候把子类的数据传给父类（这里的super必须有，super里的参数是所继承的父类实例化所需要的数据）
         super(name);
         this._age = age;
     }      work() {     　　console.log('我的工作是好好学习，天天向上。')     }}
 
 var DaMing = new Father('大明');
 DaMing.work() // 我的工作是累死累活，赚钱养家。 
var XiaoMing = new Son('小明'，15);  
XiaoMing.work(); // 我的工作是好好学习，天天向上。
```

#### 三大特征的优点

封装：封装的优势在于定义只可以在类内部进行对属性的操作，外部无法对这些属性指手画脚，要想修改，也只能通过你定义的封装方法；

继承：继承减少了代码的冗余，省略了很多重复代码，开发者可以从父类底层定义所有子类必须有的属性和方法，以达到耦合的目的；

多态：多态实现了方法的个性化，不同的子类根据具体状况可以实现不同的方法，光有父类定义的方法不够灵活，遇见特殊状况就捉襟见肘了

## 4.2 闭包+++
### 4.2.1 闭包的定义

当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。

### 4.2.2 表现形式

使函数外部能够调用函数内部定义的变量。

### 4.2.3 实例

```js
var count=10;   //全局作用域 标记为flag1
function add(){
    var count=0;    //函数全局作用域 标记为flag2
    return function(){
        count+=1;   //函数的内部作用域
        alert(count);
    }
}
var s = add()
s();//输出1
s();//输出2
```

### 4.2.4 闭包的作用

闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的**可以读取函数内部的变量**，另一个就是**让这些变量的值始终保持在内存中**，不会在调用后被自动清除。

### 4.2.5 注意点

1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。**解决方法是在退出函数之前，将不使用的局部变量全部删除。**
2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，**不要随便改变父函数内部变量的值**。

## 4.3 防抖和节流+

### 4.3.1 防抖
对于短时间内连续触发的事件，防抖的含义就是让某个事件期限内，事件处理函数只执行一次。

**非立即执行版**

```js
function debounce(func, wait) {//非立即执行版
    let timeout;
    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        
        timeout = setTimeout(() => {
            func.apply(context, args);
        }, wait);
    }
}

function scrollTop(){
    console.log("触发了一次");
}

window.onscroll = debounce(scrollTop,1000);//隔1秒后再触发一次
```
**立即执行版**

```js
function debounce(func, wait){//立即执行版
    let timeout;
    return function(){
        let context = this;
        let args = arguments;
        if(timeout) clearTimeout(timeout);
        
        let callNow = !timeout;
        timeout = setTimeout(()=>{
            timeout = null;
        }, wait);
        if(callNow) func.apply(context,args);
    }
}

function scrollTop(){
    console.log("触发了一次");
}

window.onscroll = debounce(scrollTop,1000);//每隔1秒触发一次
```



**组合版**：

```js
/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */
function debounce(func,wait,immediate) {
    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(() => {
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args);
            }, wait);
        }
    }
}
```



### 4.3.2 节流

**所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。**节流会稀释函数的执行频率。对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。

**时间戳版**：

```js
function throttle(func, wait) {
    let previous = 0;
    return function() {
        let now = Date.now();
        let context = this;
        let args = arguments;
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
```



**定时器版**：

```jsx
function throttle(func, wait){
    let timeout;
    return function(){
        let context = this;
        let args = arguments;
        if(!timeout){
            timeout = setTimeout(()=>{
                timeout = null;
                func.apply(context, args);
            }, wait);
        }
    }
}
```

**组合版**：

```jsx
/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */
function throttle(func, wait ,type) {
    if(type===1){
        let previous = 0;
    }else if(type===2){
        let timeout;
    }
    return function() {
        let context = this;
        let args = arguments;
        if(type===1){
            let now = Date.now();

            if (now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        }else if(type===2){
            if (!timeout) {
                timeout = setTimeout(() => {
                    timeout = null;
                    func.apply(context, args)
                }, wait)
            }
        }
    }
}
```



## 4.3 继承++

面向对象的基本特征有：封闭、继承、多态。

在JavaScript中实现继承的方法：

1. 原型链（prototype chaining）

2. call()/apply()

3. 混合方式(prototype和call()/apply()结合)

4. 对象冒充

### 4.3.1 prototype方法

```js
function car(price){
    this.price = price;
}
car.prototype.sayPrice = function(){
    console.log("Price is "+this.price);
}
var oCar = new car("100W");
oCar.sayPrice();
 
function toyCar(price){
    this.price = price;
}
toyCar.prototype = new car();
var oCar2 = new toyCar("10CNY");
oCar2.sayPrice();
```



### 4.3.2 call()/apply()方法

```js
function useCall(a,b){
  this.a = a;
  this.b = b;
  this.say = function(){
      console.log("I'm "+this.a+" You're "+this.b);
  }
 }
 function callThefunction (){
    var args = arguments;
    useCall.call(this,args[0],args[1]);
   // useCall.apply(this,arguments);
  }
var testCall1 = new useCall("Not YY","Not TT");
testCall1.say();
 
var testCall2 = new callThefunction("YY","TT");
testCall2.say();

//  I'm Not YY You're Not TT
//  I'm YY You're TT
```



### 4.3.3 混合方法

```js
//line=readline()
//print(line)

var Person = function(name,age){
    this.name = name;
    this.age = age;
}

var Employee = function(name,age,id){
    this.id = id;
    Person.call(this,name,age);
}

Employee.prototype = new Person();

var employee = new Employee("Jack", 20, 1);
console.log(employee.name);
console.log(employee instanceof Employee);

console.log(employee instanceof Person);
```



### 4.3.4 对象冒充

```js
function Person(name,age){
   this.name = name;
   this.age = age;
   this.show = function(){
       console.log(this.name+",  "+this.age);
   }
}
Person.prototype.sayHi = function(){
   alert('hi');
}
 
function Student(name,age){ 
   this.student = Person;   //将Person类的构造函数赋值给this.student
   this.student(name,age);  //js中实际上是通过对象冒充来实现继承的
   delete this.student;    //移除对Person的引用
}
 
var s = new Student("小明",17);
s.show();
 
var p = new Person("小花",18);
p.show();
// 小明,  17
// 小花,  18
```

### 4.3.5 ES6方法

```js
class Father {
    constructor(name) {
        this._name = name;
    }　　　//实例方法，通过实例对象调用
    getName() {
        console.log(this._name);
    }
　　// 静态方法不会被继承,并且是通过类名去调用的　　　
    static hitXiaoMing() {
        console.log("打小明")
    }
}
 
class Son extends Father {
    constructor(name, age) {
        //实例化子类的时候把子类的数据传给父类（这里的super必须有，super里的参数是所继承的父类实例化所需要的数据）
        super(name);
        this._age = age;
    } 
}
```

## 4.4 DOM操作（添加、移除、移动、复制、创建和查找节点）

### 4.4.1 DOM及DOM树

文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。

DOM就是由节点组成的。

<img src="https://images2018.cnblogs.com/blog/1364810/201805/1364810-20180528220440235-730879308.png" alt="DOM树" style="zoom:50%;" />

- **元素节点**：HMTL标签。
- **文本节点**：标签中的文字（比如标签之间的空格、换行）
- **属性节点**：：标签的属性。

### 4.4.2 查找节点

```js
var div1 = document.getElementById("box1");      //方式一：通过id获取单个标签
var arr1 = document.getElementsByTagName("div1");     //方式二：通过 标签名 获得 标签数组，所以有s
var arr2 = document.getElementsByClassName("hehe");  //方式三：通过 类名 获得 标签数组，所以有s

document.getElementsByTagName("div1")[0];    //取数组中的第一个元素
document.getElementsByClassName("hehe")[0];  //取数组中的第一个元素
```

#### 查找父节点、子节点及兄弟结点

![img](https://images2018.cnblogs.com/blog/1364810/201805/1364810-20180528220938094-853745001.png)

**childNodes**：标准属性。返回的是指定元素的**子节点**的集合（包括元素节点、所有属性、文本节点）。是W3C的亲儿子。返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等。

**children**：非标准属性。返回的是指定元素的**子元素节点**的集合。【重要】返回一个实时的 HTMLCollection ，子节点都是Element。

#### nodeType

这里讲一下nodeType。

- **nodeType == 1 表示的是元素节点**（标签） 。记住：元素就是标签。
- nodeType == 2 表示是属性节点 了解
- nodeType == 3 是文本节点 了解

### 4.4.3 添加

#### 创建元素

```js
let elem = document.createElement("div");
elem.id = 'newDiv';  
elem.style = 'color: red';  
elem.innerHTML = '我是新创建的测试节点';  
document.body.appendChild(elem); 
```

#### 创建文本节点

```js
var node = document.createTextNode("我是文本节点");  
document.body.appendChild(node); 
```

#### 克隆节点

node.cloneNode(true/false) ，它接收一个bool参数，用来表示是否复制子元素。

```js
var from = document.getElementById("test");  
var clone = from.cloneNode(true);  
clone.id = "test2";  
document.body.appendChild(clone);  
```

### 4.4.4 修改

#### 插入节点（在父节点的最后插入）

```js
var father = document.getElementById("father"); 
var son = document.getElementById("son");
father.appendChild(son);
```

#### 插入节点（前插）

```js
parentNode.insertBefore(newNode, refNode);  
```

#### 插入临近节点

```js
targetElement.insertAdjacentElement(position, element);
```

#### 替换节点

```js
parent.replaceChild(newChild, oldChild);  
```

#### 删除节点

removeChild用于删除指定的子节点并返回子节点，语法：

```js
var deletedChild = parent.removeChild(node);  
```

### 4.4.5 getElementByXXX与querySelector的区别

getElementByXXX 获取的是动态集合，querySelector获取的是静态集合（选出的所有元素的数组，不会随着文档操作而改变。）

## 4.5 new 操作符

new操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象

1. 创建一个空的对象

   ```js
   var obj = new Object();
   ```

2. 链接到原型(当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象)

   ```js
   obj.__proto__= Func.prototype;
   ```

3. 绑定this指向，执行构造函数

   让Func中的this指向obj，并执行Func的函数体。(创建新的对象之后，将构造函数的作用域赋给新对象[因此this就指向了这个新对象])

   ```js
   var result =Func.call(obj);
   ```

4. 确保返回的是对象

   判断Func的返回值类型：如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象

   ```js
   if (typeof(result) == "object"){
     func=result;
   }
   else{
       func=obj;;
   }
   ```

默认情况下函数返回值为undefined，即没有显示定义返回值的话，但构造函数例外，new构造函数在没有return的情况下默认返回新创建的对象。

但是，在有显示返回值的情况下，如果返回值为基本数据类型{string，number，null，undefined，Boolean}，返回值仍然是新创建的对象。

只有在显示返回一个非基本数据类型时，函数的返回值才为指定对象。在这种情况下，this所引用的值就会被丢弃了。

## 4.6 HTML5离线存储

## 4.7 JS的数据类型+

### 4.7.1 基本数据类型

Number，String，Boolean，undefined，null，Symbol（es6新增）

### 4.7.2 引用数据类型

Object，其中包含Function、Array，Date等

### 4.7.3 判断数据类型

#### typeof

返回数据类型，包含这7种： number、boolean、symbol、string、object、undefined、function。

typeof null  返回object

引用类型，除了function返回function类型外，其他均返回object。

#### toString

toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。

```js
Object.prototype.toString.call('') ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(Symbol()); //[object Symbol]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(new Function()) ; // [object Function]
Object.prototype.toString.call(new Date()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
Object.prototype.toString.call(new Error()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用
```

#### constructor

constructor是原型prototype的一个属性，当函数被定义时候，js引擎会为函数添加原型prototype，并且这个prototype中constructor属性指向函数引用， 因此重写prototype会丢失原来的constructor。

1：null 和 undefined 无constructor，这种方法判断不了。

2：还有，如果自定义对象，开发者重写prototype之后，原有的constructor会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。

```js
''.constructor == String //true
new Number(1).constructor == Number // true
true.constructor == Boolean //true
new Function().constructor == Function //true
new Date().constructor == Date //true
new Error().constructor == Error //true
[].constructor == Array //true
document.constructor == HTMLDocument //true
window.constructor == Window //true
```

#### instanceof

instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：**instanceof 检测的是原型**

![原型链](https://img2018.cnblogs.com/blog/1334093/201904/1334093-20190422160537795-2137053556.png)

**由上图可以看出[]的原型指向Array.prototype，间接指向Object.prototype, 因此 [] instanceof Array 返回true， [] instanceof Object 也返回true。**

**instanceof 只能用来判断两个对象是否属于实例关系****， 而不能判断一个对象实例具体属于哪种类型。**

## 4.8 null和undefined的区别

```js
console.log(null==undefined)//true
console.log(null===undefined)//false
```



4.9 call()和apply()的区别+

## 4.10 深拷贝和浅拷贝+

深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。

### 4.10.1 浅拷贝（shallowCopy）

1. 对于**基本数据类型**的成员对象，因为基础数据类型是值传递的，所以是**直接将属性值赋值给新的对象**。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。
2. 对于**引用类型**，比如数组或者类对象，因为引用类型是引用传递，**所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间**。改变其中一个，会对另外一个也产生影响。

![浅拷贝](https://upload-images.jianshu.io/upload_images/8878793-61eb6dbc8885a9bc.png?imageMogr2/auto-orient/strip|imageView2/2/w/670/format/webp)

```js
object.assign(target,source)
```

 **Object.assign** 方法只复制源对象中可枚举的属性和对象自身的属性
 如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性
 `Object.assign` 会跳过那些值为 `null`的属性

### 4.10.2 深拷贝（deepCopy）

是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。

#### 深拷贝的方法

1. **JSON.parse(JSON.stringify())**

   缺点：不可拷贝一些特殊属性，例如正则表达式，undefined和function

   ```js
   function deepCopy(o) {
       return JSON.parse(JSON.stringify(o))
   }
   
   var c = {
       age: 1,
       name: undefined,
       sex: null,
       tel: /^1[34578]\d{9}$/,
       say: () => {
           console.log('hahha')
       }
   }
   // { age: 1, sex: null, tel: {} }
   ```

2. **递归调用，复制所有层级属性**

    ```js
    var obj = {
        a:1,
        arr: [1,2]，
        nation : '中国',
        birthplaces:['北京','上海','广州']
    };
    var obj2 = {name:'杨'};
    obj2 = deepCopy(obj,obj2);
    console.log(obj2);
    //深复制，要想达到深复制就需要用递归
    function deepCopy(o, c){
        var c = c || {};
        for(var i in o){
            if(typeof o[i] === 'object'){
                if(o[i].constructor === Array){
                    //这是数组
                    c[i] = [];
                }else{
                    //这是对象
                    c[i] = {};
                }
                deepCopy(o[i], c[i]);
            }else{
                c[i] = o[i];
            }
        }
        return c;
    }
    ```



4.11 ajax

## 4.12 数组去重+

### 4.12.1 使用ES6中的Set方法

```js
let arr = [1,0,0,2,9,8,3,1];
function unique(arr) {
    return Array.from(new Set(arr))
}
console.log(unique(arr));   // [1,0,2,9,8,3]
```

4.13 this对象+
4.14 eval()
4.15 什么是UA?

## 4.16 什么是事件委托？

事件委托，通俗地来讲，就是把一个元素响应事件（click、focus……）的函数委托到另一个元素；

### 4.16.1 事件模型的三个阶段

- 捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；
- 目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；
- 冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；

![js事件模型](http://static.codeceo.com/images/2017/04/v2-716a278ff4bcc2aca259d4ca7018cba3_b.png)

### 4.16.2 事件委托的优点

#### 减少内存消耗

若果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件；

```html
<ul id="list">
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
  <!-- 多个li -->
  <li>item n</li>
</ul>
```

如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能；

因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 `ul` 上，然后在执行事件的时候再去匹配判断目标元素；

所以事件委托可以减少大量的内存消耗，节约效率。

#### 动态事件绑定

在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；

如果用了事件委托就没有这种麻烦了，因为**事件是绑定在父层的，和目标元素的增减是没有关系的**，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；

所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。

### 4.16.3 jQuery 中的事件委托

jQuery 中的事件委托相信很多人都用过，它主要这几种方法来实现：

- `$.on`: 基本用法: 
```js
$('.parent').on('click', 'a', function () { 
    console.log('click event on tag a'); 
})
```

它是 .parent 元素之下的 a 元素的事件代理到 `$('.parent')` 之上，只要在这个元素上有点击事件，就会自动寻找到 .parent 元素下的 a 元素，然后响应事件

- `$.delegate`: 基本用法: 

```js
$('.parent').delegate('a', 'click', function () { 
    console.log('click event on tag a'); 
})
```

- 同上，并且还有相对应的 $.delegate 来删除代理的事件；

- `$.live`: 基本使用方法: 

- ```js
  $('a', $('.parent')).live('click', function () {
      console.log('click event on tag a'); 
  })
  ```

- 同上，然而如果没有传入父层元素 \$(.parent)，那事件会默认委托到 $(document) 上；(已废除)

## 4.17 promise++

### 4.17.1 什么是Promise

Promise是一种封装未来值的易于复用的异步任务管理机制。

- 等待（pending）：初始状态；
- 已完成（fulfilled）：操作成功完成；
- 被拒绝（rejected）：操作失败；

这三个状态变更关系需满足以下三个条件：

- 处于等待（pending）状态时，可以转变为已完成（fulfilled）或者被拒绝状态（rejected）；
- 处于已完成状态时，状态不可变，且需要有一个最终值；
- 处于被拒绝状态时，状态不可变，且需要有一个拒绝原因。

### 4.17.2 then方法

一个promise必须提供一个`then`方法，以供访问其当前状态，或最终值或拒绝原因。

**参数**

该方法接收两个参数，如`promise.then(onFulfilled, onRejected)`:

- 两个参数均为可选，均有默认值，若不传入，则会使用默认值；
- 两个参数必须是函数，否则会被忽略，使用默认函数；
- onFulfilled: 在promise已完成后调用且仅调用一次该方法，该方法接受promise最终值作参数；
- onRejected: 在promise被拒绝后调用且仅调用一次该方法，该方法接受promise拒绝原因作参数；
- 两个函数都是异步事件的回调，符合JavaScript事件循环处理流程

**返回值**

该方法必须返回一个promise

### 4.17.3 实例

```js
var promise = new Promise((resolve, reject) => {
        setTimeout(function() {
            resolve('完成');
        }, 10);
    });
    promise.then((msg) => {
        console.log('first messaeg: ' + msg);
    })
    promise.then((msg) => {
        console.log('second messaeg: ' + msg);
    });
```

### 4.17.4 Promise.all(iterable)

all方法接受一个或多个promsie（以数组方式传递），返回一个新promise，该promise状态取决于传入的参数中的所有promsie的状态：

1. 当所有promise都完成是，返回的promise完成，其最终值为由所有完成promsie的最终值组成的数组；
2. 当某一promise被拒绝时，则返回的promise被拒绝，其拒绝原因为第一个被拒绝promise的拒绝原因；

```js
var p1 = new Promise((resolve, reject) => {
    setTimeout(function(){
        console.log('p1决议');
        resolve('p1');
    }, 10);
});
var p2 = new Promise((resolve, reject) => {
    setTimeout(function(){
        console.log('p2决议');
        resolve('p2');
    }, 10);
});
Promise.all( [p1, p2] )
    .then((msgs) => {
    // p1和p2完成并传入最终值
    console.log(JSON.stringify(msgs));
})
    .then((msg) => {
    console.log( msg );
});

/*output:
p1决议
p2决议
["p1","p2"]
undefined
*/
```

#### 实现promise.all

```js
Promise.all = function(promises) {
    return new Promise(function(resolve, reject) {
        var resolvedCounter = 0;
        var promiseNum = promises.length;
        var resolvedValues = new Array(promiseNum);
        for (let i=0;i<promisesLength;i++) {
            Promise.resolve(promises[i]).then(function(value) {
                promiseCount++;
                results[i] = value;
                // 当所有函数都正确执行了，resolve输出所有返回结果。
                if (promiseCount === promisesLength) {
                    return resolve(resolvedValues);
                }
            }, function(err) {
                return reject(err);
            });
        }
    });
};

Promise.race = function(promises){
    return new Promise(function(resolve, reject) {
      for (let i = 0; i < promises.length; i++) {
        Promise.resolve(promises[i]).then(function(value) {
          return resolve(value)
        }, function(reason) {
          return reject(reason)
        })
      }
    })
}
```



### 4.17.5 Promise.race(iterable)

race方法返回一个promise,只要传入的诸多promise中的某一个完成或被拒绝，则该promise同样完成或被拒绝，最终值或拒绝原因也与之相同。

## 4.18 window.onload和document.ready的区别？哪一个先执行？+

document.ready方法在DOM树加载完成后就会执行，

而window.onload是在页面资源（比如图片和媒体资源，它们的加载速度远慢于DOM的加载速度）加载完成之后才执行。

也就是说$(document).ready要比window.onload先执行。

## 4.19 var、let和const有什么区别+

## 4.20 JavaScript 启动后，内存中有多少个对象？如何用代码来获得这些信息？

## 4.21 JavaScript事件执行机制？宏任务、微任务+

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xcWFkYXB0LnFwaWMuY24vdHhkb2NwaWMvMC9kN2VjMmFiYTVjOTk1ZTQ4ODlmYTU1YzZhYjMyM2E5Ni8w?x-oss-process=image/format,png" alt="js事件处理机制" style="zoom:50%;" />

js会将同步和异步任务分别放入不同的执行"场所"，同步的进入主线程(先执行，同步任务实质上是一个宏任务)，异步任务进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。（指定的事情比如setTimeout的定义的时间完成时）主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的Event Loop(事件循环)。js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后再执行微任务，将微任务放入eventqueue。**值得注意，这两个queue不是一个queue**。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的queue上拿宏任务的回调函数。异步事件执行的最快时间是4ms。

宏任务 => 微任务的Event Queue => 宏任务的Event Queue

**宏任务和微任务的分类**

macro task（宏任务）: 同步代码(整块script代码)、setImmediate、MessageChannel、setTimeout/setInterval

micro task（微任务）: Promise.then（不是promise，promise会立即执行）、MutationObserver，还有process.nextTick等。



```js
async function async1() { 
     console.log('async1 start'); //4.同步执行，输出
     await async2(); //5.同步执行，进入函数async2
     console.log('async1 end');//7.异步，加入事件队列 10.进入事件队列执行，输出
} 

async function async2() {    
    console.log('async2'); //6.同步执行，输出
} 
// 0.开始同步执行
console.log('script start'); //1.同步执行，输出

setTimeout(function() {    
    console.log('setTimeout'); //2.当定时器的时间到了之后，加入事件队列，若事件队列已有很多任务，则放置于其之后 12.计时结束，输出
}, 0); 

async1(); //3.执行函数，进入

new Promise(function(resolve) {    
    console.log('promise1'); //7.同步执行，输出
    resolve(); 
}).then(function() { 
    console.log('promise2'); //8.加入异步队列 11.进入事件队列执行，输出
}); 

console.log('script end'); //9.同步执行，输出

//执行顺序：
/*script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
*/
```

![执行流程](https://img-blog.csdnimg.cn/20190322161332450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1bl9ob3U=,size_16,color_FFFFFF,t_70)

## 4.22 `==` 与 `===` 的区别 +

== 在比较时等号左右两侧数据类型不同时会先转成相同数据类型，再比较。

== 是相对比较； === 是绝对比较；

**==比较**

比较方法：

1. 字符串 == 数字 ；字符串转换成数字
2. 布尔值 == 数字; 布尔值转成数字
3. 布尔值 == 字符串; 布尔值转数字，字符串也转成数字，然后进行比较；
4. null == undefined // true, null 和undefined和其他数据类型比较都是false
5. 对象 == 对象; 比较的是空间地址，地址相同返回true
6. 对象 == 字符串; 对象转成字符串，然后和字符串比较
7. 对象 == 布尔值；对象先转成字符串，再转数字，布尔值也转成数字，在比较这两个数字
8. 对象 == 数字；对象先转成字符串，然后再转成数字
9. NaN和NaN永远不相等

 ```js
{} == '[object Object]' //true
[] == false //true
{} == true //false
{} == 1 //false
[] == 0 //true
NaN == NaN //false
 ```

![==](https://pic3.zhimg.com/80/41b28b0c6def1909e0ad1da86093e620_720w.jpg?source=1940ef5c)

**===比较**

![img](https://pic4.zhimg.com/80/eb4c38443744d02015ddbe9bfd775eb3_720w.jpg?source=1940ef5c)

**完整比较图**

- 红色：===
- 橙色：==
- 黄色：<= 和 >= 同时成立，== 不成立
- 蓝色：只有 >=
- 绿色：只有 <=

![完整比较图](https://pic3.zhimg.com/80/b922270259dece707ef6c6a50259a406_720w.jpg?source=1940ef5c)

## 4.23 数组操作函数有哪些？哪些是es6新增的？+

### 4.23.1 数组遍历

for：

普通版：for(let i=0; i<arr.length; i++) { }

优化版：for(let i=0,len=arr.length; i<len; i++) { }

弱化版：for(let i=0; arr[i] != null; i++) { }

forEach： arr.forEach((e, index) => { }) 性能比for要弱

变种：Array.prototype.forEach.call(arr, (el, index) => { }) 实际性能要比普通的foreach弱

for...in... ：for(let i in arr) { }  效率最低

for...of...：for(let i of arr) { } 性能好于forin

### 4.23.2 转换方法

toString: 将 **Array** 的元素转换为字符串。结果字符串由逗号分隔，且连接起来。

toLocaleString: 转为本地化语言字符串

valueOf: 数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起。其操作与 **Array.toString** 和 **Array.join**方法相同。

### 4.23.3 栈方法

push()：向数组的末尾添加一个或多个元素，并返回新的长度

pop()：删除数组的最后一个元素，数组的长度减1，并且返回删除元素的值(数组为空时，不改变数组，并返回undefined)

### 4.23.4 队列方法

unshift()：向数组的头部添加一个或多个元素，返回新的长度

shift()：删除并返回数组的第一个元素

### 4.23.5 重排序方法

reverse()：颠倒数组中的元素顺序

sort()：对数组元素进行排序（默认按照ASCII）

```js
let arr = [0,1,5,10,15];
arr.sort();//0,1,10,15,5
arr.sort((a,b)=>a>b);// 0,1,5,10,15
```

### 4.23.6 操作方法

concat():链接两个或多个数组

slice(start, end)：从某个已有的数组返回选定的元素(没有end参数时就到数组结尾)

splice(start,count,...insertedValues)：删除元素，并向数组添加新元素

### 4.23.7 位置方法

indexOf(x, start)、lastIndexOf()：查找数组元素的位置，参数：要查的项和起点位置索引

### 4.23.8 迭代方法

map()：arr.map((n) => { }) 实际效率还比不上forEach

every()：数组的每一项都满足给定条件则返回true

some()：数组中只要有一项满足条件就返回true

filter()：返回满足给定条件的数据项组成的新数组，不改变原数组

forEach(): 对数组中的每一项运行给定函数。无返回值。

### 4.23.9 归并方法

reduce()、reduceRight()：迭代所有的项，构建一个最终的返回值。

### 4.23.10 ES6新增数组操作

1. **Array.from()** 把类数组(获取一组元素、arguments…) 对象转成数组

```js
1、字符串转数组(个人感觉有些类似于arr.split(""))：
let str = "hello";
console.log(Array.from(str));	//Array(5) ["h", "e", "l", "l", "o"]

2、将类数组对象转换为真正数组：
let arrList = {
    0: 'yang', 
    1: '27',
    2: '男',
    3: ['wang','ling','huang'],
    'length': 4
}
let arr = Array.from(arrList)
console.log(arr) // Array(4) ['yang','27','男',['wang','ling','huang']]

PS：对于第二种，如果将最后的length去掉，那将是一个length为0的空数组

如果将代码再改一下：
let arrList = {
    'name': 'yang', 
    'age': '27',
    'sex': '男',
   	'fre': ['wang','ling','huang'],
    'length': 4
}
let arr = Array.from(arrList)
console.log(arr) // Array(4) [undefined, undefined, undefined, undefined]
会发现结果是长度为4，元素均为undefined的数组

由此可见，要将一个类数组对象转换为一个真正的数组，必须具备以下条件：
1、该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组
2、该类数组对象的属性名必须为数值型或字符串型的数字
```

2. **Array.of()** 把一组值,转化数组

```js
let arr = Array.of('apple','banana','orange');
```

3. **arr.find()** 查找数组内元素，找到第一个符合条件的数组成员，返回该成员的值，如果没有找到，返回undefined

4. **arr.findIndex()** 查找数组内元素，找到第一个符合条件的数组成员，返回该成员的下标（index）， 没找到返回-1

5. **arr.fill()** 填充

```
array.fill(value, start, end)
参数	描述
value	必需。填充的值。
start	可选。开始填充位置。
end	可选。停止填充位置 (默认为 Array.length)
```

6. **arr.copyWithin** 使用数组内部元素替换指定位置元素

```js
//这个东西用的不多，但是很有意思
//首先，参数有3个
//1: 被替换的起始位置   2: 选取替换值的起始位置   3: 选取替换值得结束位置
let arr = [1, 'c', 'd', 'a', 'b'];  //假如我想把a，b替换到1的位置
arr.copyWithin(0, 3, 5)   // ["a", "b", "d", "a", "b"]
```

7. **entries/keys/values**

```js
let arr=['a', 'b', 'c']
for(let key of arr.keys()){}                     //取键
for(let value of arr.values()){}                //取值；不能直接使用，有兼容性问题，甚至谷歌
for(let [key, value] of arr.entries()){}       //都取
```

8. ES2016新增

```js
arr.indexOf()	// ES5 查找指定元素是否存在，如果存在，返回下标，如果不存在返回-1
arr.includes()	// 查找指定元素是否存在，如果存在，返回true，如果不存在返回false
```

## 4.24 ES6的变化

### 4.24.1 定义变量和常量

在es5中我们经常使用`var`来声明一个变量，es6更改`let`声明

1. **不能重复声明**变量
2. 不会预处理, **不存在变量提升**
3. 用let声明的变量 如果在块内，会生成 **块作用域**

### 4.24.2 模板字符串

- 模板字符串必须用 `` 包含
- 变化的部分使用`${xxx}`定义
- 作用:简化字符串pim

```js
//使用的场景
    //比如:网址字符串的的请求

let url = `http://ezcarry.com?userName=${obj.userName}&psd=${obj.psd}`;
```

### 4.24.3 解构赋值

### 数组解构赋值

1. 在数组的解构赋值中, 等号左边的格式必须和等号右边的格式一模一样, 才能完全解构

   ```js
   let [a, b, c] = [1, 3, 5]; // 结果 a=1.b=3,c=5
   ```

2.  左边的个数可以和右边数组的个数不一样;就按照下标索引 对应赋值,如果没有对应上 就是 undefined;`b,c给定的默认值`，其实里面有判断处理，如果对应索引有值，则赋值，如果没有 使用默认值

   ```js
   let [a, b] = [1, 3, 5]; //a=1,b=3
   let [a, b, c] = [1]; //a=1,b=undefined,c=undefined
   let [a, b = 666, c = 888] = [1]; //a=1,b=666,c=888
   ```

3.  还可以使用ES6中新增的扩展运算符来打包剩余的数据, 那么**扩展运算符只能写在最后**

   ```js
   let [a, ...b] = [1, 3, 5]; //a=1,b=[3,5]
   ```

#### 对象解构赋值

对象解构赋值是比较严格的，**要和对象的属性值相同**。

```js
let {name,age} = {name:"cc",age:18}; //name="cc",age=18
```

**允许key有剩余**，就是说声明的变量的个数，不一定要和对象里面key的个数相同**，但是一旦声明**必须和key的名字形同

```js
let {name} = {name:"cc",age:18};
```

### 4.24.4 扩展运算符

```js
let [a, ...b] = [1, 3, 5];  // a = 1; b = [3, 5];

let arr1 = [1, 3, 5];
let arr2 = [2, 4, 6];
let arr = [...arr1, ...arr2]; // arr= [1, 3, 5, 2, 4, 6];
```

### 4.24.5 箭头函数及函数参数

```js
let test = ()=> {
    console.log("测试");
}
```

#### ES6中函数的扩展运算符

- 扩展运算符在函数的形参列表中的作用，将传递给函数的所有实参打包到一个**数组**中

```js
function test(...value) {//es6
    console.log(value);
}

function test() { //es5
    //arguments 伪数组  只可以 for遍历
    console.log(arguments);
}

//value 是一个真实的数组，具备数组的所有属性和方法
test(1,2,3,4,5);
```

### 4.24.6 类和对象

- ES6系统提供了一个`class`关键字 专门定义类
- `static` 来定义**静态方法**,**不可以**定义**静态属性**

```js
class Student{
    // 通过new创建的对象的时候，会自动调用constructor
    constructor(name,age){
        //属性
        this.name = name;
        this.age = age;
    }
    //实例方法
    say = function () {
        console.log(`你好，我是：${this.name},今年${this.age}`);
    }

//static 使用在 es6中 规定是 只可以定义静态方法，不可以定义静态属性，有的浏览器不支持
//静态属性  要用 static 声明
// static score = 66;
// 定义静态属性

    //静态方法
    static run = function () {
        console.log("走呀，一块跑步")
    }
    // 注意 静态方法可以简写
    // static eat = function () {}
    static eat(){
        console.log("吃饭");
    }
}

//定义静态属性
Student.score = 66;
```

## 4.25 async和await

async用于声明异步方法，await是async wait的缩写，用于等待一个异步方法执行完成。await只能出现在async函数中。async函数返回的是一个Promise对象。

# 5. 前端安全问题

## 5.1 XSS+

### 5.1.1 什么是XSS攻击

XSS全称是Cross Site Scripting即跨站脚本，当目标网站目标用户浏览器渲染HTML文档的过程中，出现了不被预期的脚本指令并执行时，XSS就发生了。

这里我们主要注意四点：1、目标网站目标用户；2、浏览器；3、不被预期；4、脚本。

### 5.1.2 XSS攻击有什么危害

- 挂马
- 盗取用户Cookie。
- DOS（拒绝服务）客户端浏览器。
- 钓鱼攻击，高级的钓鱼技巧。
- 删除目标文章、恶意篡改数据、嫁祸。
- 劫持用户Web行为，甚至进一步渗透内网。
- 爆发Web2.0蠕虫。
- 蠕虫式的DDoS攻击。
- 蠕虫式挂马攻击、刷广告、刷浏量、破坏网上数据

### 5.1.3 分类

XSS有三类：反射型XSS(非持久型)、存储型XSS(持久型)和DOM XSS。

### 5.1.4 如何防范

1. 注意特殊的 HTML 属性、JavaScript API

2. 根据上下文采用不同的转义规则

3. 预防存储型和反射型 XSS 攻击。

   1. 改成纯前端渲染，把代码和数据分隔开。
   2. 对 HTML 做充分转义。

4. Content Security Policy

   严格的 CSP 在 XSS 的防范中可以起到以下的作用：

   - 禁止加载外域代码，防止复杂的攻击逻辑。
   - 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
   - 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
   - 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
   - 合理使用上报可以及时发现 XSS，利于尽快修复问题。

5. 输入内容长度控制

6. HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。

7. 验证码：防止脚本冒充用户提交危险操作。

## 5.2 CSRF

**CSRF跨站点请求伪造(Cross—Site Request Forgery)。**攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

### 5.2.1 防御CSRF

目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。

## 5.3 爬虫+

# 6. 跨域

## 6.1 什么是跨域？+

出于浏览器的同源策略限制。即当一个请求url的**协议、域名、端口**三者之间任意一个与当前页面url不同即为跨域。

| **当前页面url**           | **被请求页面url**               | **是否跨域** | **原因**                       |
| ------------------------- | ------------------------------- | ------------ | ------------------------------ |
| http://www.test.com/      | http://www.test.com/index.html  | 否           | 同源（协议、域名、端口号相同） |
| http://www.test.com/      | https://www.test.com/index.html | 跨域         | 协议不同（http/https）         |
| http://www.test.com/      | http://www.baidu.com/           | 跨域         | 主域名不同（test/baidu）       |
| http://www.test.com/      | http://blog.test.com/           | 跨域         | 子域名不同（www/blog）         |
| http://www.test.com:8080/ | http://www.test.com:7001/       | 跨域         | 端口号不同（8080/7001）        |

## 6.2 什么是同源策略？

**同源策略**（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。  

## 6.3 非同源限制

1. 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB

2. 无法接触非同源网页的 DOM

3. 无法向非同源地址发送 AJAX 请求

## 6.4 不受同源策略限制的操作

1. 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。

2. 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的`<script src="..."></script>`，`<img>`，`<link>`，`<iframe>`等。

## 6.5 解决跨域的方法有哪些？+

### 6.5.1 设置document.domain+iframe跨域 【解决无法读取非同源网页的cookie问题】

因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）

```js
// 两个页面都设置
document.domain = 'test.com';
```

1. 父窗口

   ```html
   <iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
   <script>
       document.domain = 'domain.com';
       var user = 'admin';
   </script>
   ```

2. 子窗口

   ```html
   <script>
       document.domain = 'domain.com';
       alert('get js data from parent -->'+window.parent.user);
   </script>
   ```

### 6.5.2 location.hash +iframe跨域

实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

1. a.html (http://www.domain1.com/a.html)

   ```html
   <iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
   <script>
       var iframe = document.getElementById('iframe');
   
       // 向b.html传hash值
       setTimeout(function() {
           iframe.src = iframe.src + '#user=admin';
       }, 1000);
       
       // 开放给同域c.html的回调方法
       function onCallback(res) {
           alert('data from c.html ---> ' + res);
       }
   </script>
   ```

2. b.html (http://www.domain2.com/b.html)

   ```html
   <iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
   <script>
       var iframe = document.getElementById('iframe');
   
       // 监听a.html传来的hash值，再传给c.html
       window.onhashchange = function () {
           iframe.src = iframe.src + location.hash;
       };
   </script>
   ```

3. c.html (http://www.domain1.com/c.html)

   ```html
   <script>
       // 监听b.html传来的hash值
       window.onhashchange = function () {
           // 再通过操作同域a.html的js回调，将结果传回
           window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
       };
   </script>
   ```

### 6.5.3 window.name+iframe跨域

window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。

1. a.html：(http://www.domain1.com/a.html)

```
var proxy = function(url, callback) {
    var state = 0;
    var iframe = document.createElement('iframe');

    // 加载跨域页面
    iframe.src = url;

    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload = function() {
        if (state === 1) {
            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
            callback(iframe.contentWindow.name);
            destoryFrame();

        } else if (state === 0) {
            // 第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';
            state = 1;
        }
    };

    document.body.appendChild(iframe);

    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryFrame() {
        iframe.contentWindow.document.write('');
        iframe.contentWindow.close();
        document.body.removeChild(iframe);
    }
};

// 请求跨域b页面数据
proxy('http://www.domain2.com/b.html', function(data){
    alert(data);
});
```

2. proxy.html：([http://www.domain1.com/proxy....](http://www.domain1.com/proxy.html))
   中间代理页，与a.html同域，内容为空即可。

3. b.html：(http://www.domain2.com/b.html)

```
<script>
    window.name = 'This is domain2 data!';
</script>
```

### 6.5.4 跨文档通信API：window.postMessage()

调用postMessage方法实现父窗口http://test1.com向子窗口http://test2.com发消息（子窗口同样可以通过该方法发送消息给父窗口）

它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

用法：`postMessage(data,origin)`方法接受两个参数

- data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
- origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

```js
// 父窗口打开一个子窗口
var openWindow = window.open('http://test2.com', 'title');
 
// 父窗口向子窗口发消息(第一个参数代表发送的内容，第二个参数代表接收消息窗口的url)
openWindow.postMessage('Nice to meet you!', 'http://test2.com');

// 监听 message 消息
window.addEventListener('message', function (e) {
  console.log(e.source); // e.source 发送消息的窗口
  console.log(e.origin); // e.origin 消息发向的网址
  console.log(e.data);   // e.data   发送的消息
},false);
```

### 6.5.5 JSONP

JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。

核心思想：网页通过添加一个`<script>元素`，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。

#### 原生实现

```html
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<script>
  function handleCallback(res) {
    console.log(res);
  }

  function addScriptTag(src) {
    var scriptEle = document.createElement("script");
    $(scriptEle).attr("src", src);
    $("body").append(scriptEle);
    $(scriptEle).remove();
  }
  $("#b1").click(function () {
    addScriptTag("http://127.0.0.1:8002/abc/?callback=handleCallback")
  });
</script>
```

#### JQuery实现

```js
//使用getJSON
$("#b1").click(function () {
    $.getJSON("http://127.0.0.1:8002/abc/?callback=?", function (res) {
      console.log(res);
    })
  });

//指定回调函数名
$.ajax({
    url: 'http://127.0.0.1:8002/abc/',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: "handleCallback",    // 自定义回调函数名
    data: {}
});

$.ajax({
    url: "http://127.0.0.1:8002/abc/",
    dataType: "jsonp",
    success: function (res) {
        console.log(res);
    }
});


```

#### Vue.js实现

```js
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

6.5.4 

### 6.5.6 CORS

CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。

1. **普通跨域请求：只需服务器端设置Access-Control-Allow-Origin**

2. **带cookie跨域请求：前后端都需要进行设置**

#### 前端设置

根据xhr.withCredentials字段判断是否带有cookie

1. **原生ajax**

   ```js
   var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容
    
   // 前端设置是否带cookie！！
   xhr.withCredentials = true;
    
   xhr.open('post', 'http://www.domain2.com:8080/login', true);
   xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
   xhr.send('user=admin');
    
   xhr.onreadystatechange = function() {
       if (xhr.readyState == 4 && xhr.status == 200) {
           alert(xhr.responseText);
       }
   };
   ```

2. **JQuery ajax**

   ```js
   $.ajax({
      url: 'http://www.test.com:8080/login',
      type: 'get',
      data: {},
      xhrFields: {
          withCredentials: true    // 前端设置是否带cookie
      },
      crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
   });
   ```

3. **Vue框架**

   ```js
   Vue.http.options.credentials = true //vue-resource
   axios.defaults.withCredentials = true //axios
   ```

#### 服务端设置

服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。

1. Java后台

    ```java
    /*
     * 导入包：import javax.servlet.http.HttpServletResponse;
     * 接口参数中定义：HttpServletResponse response
     */

    // 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'
    response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); 

    // 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示
    response.setHeader("Access-Control-Allow-Credentials", "true"); 

    // 提示OPTIONS预检时，后端需要设置的两个常用自定义头
    response.setHeader("Access-Control-Allow-Headers", "Content-Type,X-Requested-With");
    ```

2. node.js后台

   ```js
   var http = require('http');
   var server = http.createServer();
   var qs = require('querystring');
    
   server.on('request', function(req, res) {
       var postData = '';
    
       // 数据块接收中
       req.addListener('data', function(chunk) {
           postData += chunk;
       });
    
       // 数据接收完毕
       req.addListener('end', function() {
           postData = qs.parse(postData);
    
           // 跨域后台设置
           res.writeHead(200, {
               'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
               'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
               /* 
                * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
                * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
                */
               'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
           });
    
           res.write(JSON.stringify(postData));
           res.end();
       });
   });
    
   server.listen('8080');
   console.log('Server is running at port 8080...');
   ```

### 6.5.7 nginx代理跨域

### 6.5.8 Nodejs中间件代理跨域

### 6.5.9 WebSocket协议跨域

## 6.6 CORS详解

### 6.6.1 两种请求

浏览器将CORS请求分成两类：**简单请求**（simple request）和**非简单请求**（not-so-simple request）。

**简单请求（只要满足以下两大条件）：**

1. 请求方法是以下三种方法之一：HEAD、GET、POST
2. HTTP请求头中仅包含以下几种字段：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type：仅限于application/x-www-form-urlencoded、multipart/form-data、text/plain

为了兼容表单form，AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。凡是不同时满足上面两个条件，就属于非简单请求。

### 6.6.2 简单请求

#### 基本流程

对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个`Origin`字段。用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。

服务器根据这个值，决定是否同意这次请求。

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

```http
Access-Control-Allow-Origin: http://api.bob.com 
Access-Control-Allow-Credentials: true 
Access-Control-Expose-Headers: FooBar 
Content-Type: text/html; charset=utf-8
```

**Access-Control-Allow-Origin**：必须。它的值要么是请求时Origin字段的值，要么是一个`*`，表示接受任意域名的请求。

**Access-Control-Allow-Credentials**：可选。布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可Cookie。

**Access-Control-Expose-Headers**：可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。

#### withCredentials属性

允许携带cookie

### 6.6.3 非简单请求

#### 预检请求

非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。一旦服务器通过了**"**预检**"**请求，以后每次浏览器正常的**CORS**请求，就都跟简单请求一样，会有一个**Origin**头信息字段。

**浏览器端**

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

```js
var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
```

上面代码中，HTTP请求的方法是`PUT`，并且发送一个自定义头信息`X-Custom-Header`。

浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息。

```http
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

"预检"请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。

除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

**Access-Control-Request-Method**：必须。用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是`PUT`。

**Access-Control-Request-Headers**：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是`X-Custom-Header`。



**服务器端**

发送该请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通。

```http
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
```

**Access-Control-Allow-Origin**：与简单的请求相同。

**Access-Control-Allow-Credentials**：与简单的请求相同。

**Access-Control-Allow-Methods**：必须。它的值是逗号分隔的一个字符串，表明服务器**支持的所有跨域请求**的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。**这是为了避免多次"预检"请求。**

**Access-Control-Allow-Headers**：如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。

**Access-Control-Max-Age**：可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

# 7. 性能优化

7.1 你都用过那种性能优化的方法？
7.2 CSS Sprite是什么，谈谈这个技术的优缺点

# 8. Vue.js

## 8.1 Vue如何实现双向绑定+

Vue采用数据劫持结合发布者-订阅者模式的方法，通过**Object.defineProperty()**来劫持各个属性的setter,getter属性，在数据变动话，通知订阅者，触发更新回调函数，重新渲染视图.

![vue响应式](https://pic1.zhimg.com/80/v2-b94d747fd273ec8224e6349f701430fd_720w.jpg)

![vue双向绑定](https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225458132-1434604303.png)

### 8.1.1 核心实现类:

**Observer** : 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新

**Dep** : 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。

**Watcher** : 观察者对象 , 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种

### 8.1.2 Watcher 和 Dep 的关系

watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者,dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。

### 8.1.3 依赖收集

1. initState 时,对 computed 属性初始化时,触发 computed watcher 依赖收集
2. initState 时,对侦听属性初始化时,触发 user watcher 依赖收集
3. render()的过程,触发 render watcher 依赖收集
4. re-render 时,vm.render()再次执行,会移除所有 subs 中的 watcer 的订阅,重新赋值。

### 8.1.4 派发更新

1. 组件中对响应的数据进行了修改,触发 setter 的逻辑
2. 调用 dep.notify()
3. 遍历所有的 subs（Watcher 实例）,调用每一个 watcher 的 update 方法。

### 8.1.5 原理

当创建 Vue 实例时,vue 会遍历 data 选项的属性,利用 Object.defineProperty 为属性添加 getter 和 setter 对数据的读取进行劫持（getter 用来依赖收集,setter 用来派发更新）,并且在内部追踪依赖,在属性被访问和修改时通知变化。

每个组件实例会有相应的 watcher 实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有 computed watcher,user watcher 实例）,之后依赖项被改动时,setter 方法会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。

一句话总结:

vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调

### 8.1.1 Vue3中的变化

使用es2015中的Proxy替代Object.defineProperty。Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x 里,是通过 递归 + 遍历 data 对象来实现对数据的监控的,如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。Proxy 可以劫持整个对象,并返回一个新的对象。Proxy 不仅可以代理对象,还可以代理数组。还可以代理动态增加的属性。

## 8.2 computed的实现原理

computed 本质是一个惰性求值的观察者。

computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。

其内部通过 this.dirty 属性标记计算属性是否需要重新求值。

当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,

computed watcher 通过 this.dep.subs.length 判断有没有订阅者,

有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (**Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。**)

没有的话,仅仅把 this.dirty = true。 (**当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。**)

## 8.3 computed和watch的区别

**computed** 依赖其他的值,且具有缓存,缓存变化才会更新。**计算属性是基于它们的响应式依赖进行缓存的**

- 只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 进行数值计算，并且依赖于其它数据用它

**watch** 没有缓存 监听某一个值 变化进行一些操作

- 数据变化时执行异步或开销较大的操作时用它，使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。

## 8.4 vue的diff算法

我们先根据真实DOM生成一颗`virtual DOM`，当`virtual DOM`某个节点的数据改变后会生成一个新的`Vnode`，然后`Vnode`和`oldVnode`作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使`oldVnode`的值为`Vnode`。

diff的过程就是调用名为`patch`的函数，比较新旧节点，一边比较一边给**真实的DOM**打补丁。

### diff的比较方式？

在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。

## 8.5 vue中key的作用

key 是给每一个 vnode 的唯一 id,依靠 key,我们的 diff 操作可以更准确、更快速 (对于简单列表页渲染来说 diff 节点也更快,但会产生一些隐藏的副作用,比如可能不会产生过渡效果,或者在某些节点有绑定数据（表单）状态，会出现状态错位。)

diff 算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的 key 与旧节点进行比对,从而找到相应旧节点。



**更准确 :** 因为带 key 就不是就地复用了,在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确,如果不加 key,会导致之前节点的状态被保留下来,会产生一系列的 bug。

**更快速 :** key 的唯一性可以被 Map 数据结构充分利用,相比于遍历查找的时间复杂度 O(n),Map 的时间复杂度仅仅为 O(1)

## 8.6 nextTick的原理

Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。

如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。

然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。

Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。

**nextTick 方法的实现原理:**

1. vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调先后执行
2. microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕
3. 考虑兼容问题,vue 做了 microtask 向 macrotask 的降级方案。

## 8.7 Vue对数组的监听，如何对数组方法进行变异

Vue 通过原型拦截的方式重写了数组的 7 个方法,首先获取到这个数组的**ob**,也就是它的 Observer 对象,如果有新的值,就调用 observeArray 对新的值进行监听,然后手动调用 notify,通知 render watcher,执行 update

## 8.8 vue组件中data为什么必须是函数

因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。

所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题。

## 8.9 谈谈vue的事件机制，手写`$on,$off,$emit,$once`

Vue 事件机制 本质上就是 一个 发布-订阅 模式的实现。

```js
class Vue {
  constructor() {
    //  事件通道调度中心
    this._events = Object.create(null);
  }
  $on(event, fn) {
    if (Array.isArray(event)) {
      event.map(item => {
        this.$on(item, fn);
      });
    } else {
      (this._events[event] || (this._events[event] = [])).push(fn);
    }
    return this;
  }
  $once(event, fn) {
    function on() {
      this.$off(event, on);
      fn.apply(this, arguments);
    }
    on.fn = fn;
    this.$on(event, on);
    return this;
  }
  $off(event, fn) {
    if (!arguments.length) {
      this._events = Object.create(null);
      return this;
    }
    if (Array.isArray(event)) {
      event.map(item => {
        this.$off(item, fn);
      });
      return this;
    }
    const cbs = this._events[event];
    if (!cbs) {
      return this;
    }
    if (!fn) {
      this._events[event] = null;
      return this;
    }
    let cb;
    let i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return this;
  }
  $emit(event) {
    let cbs = this._events[event];
    if (cbs) {
      const args = [].slice.call(arguments, 1);
      cbs.map(item => {
        args ? item.apply(this, args) : item.call(this);
      });
    }
    return this;
  }
}
```

## 8.10 Vue的渲染过程

![vue的渲染过程](https://pic3.zhimg.com/80/v2-53a8ab7de0ebb4935f0c0583f313c3c7_720w.jpg)

1. 调用 compile 函数,生成 render 函数字符串 ,编译过程如下:
   1. parse 函数解析 template,生成 ast(抽象语法树)
   2. optimize 函数优化静态节点 (标记不需要每次都更新的内容,diff 算法会直接跳过静态节点,从而减少比较的过程,优化了 patch 的性能)
   3. generate 函数生成 render 函数字符串

2. 调用 new Watcher 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象

3. 调用 patch 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素

## 8.11 keep-alive 的实现原理和缓存策略 ？？

```js

```



## 8.12 vm.$set()的实现原理



# 9. Webpack

## 9.1 核心概念

1. entry：一个可执行模块或者库的入口。

2. chunk：多个文件组成一个代码块。可以将可执行的模块和他所依赖的模块组合成一个chunk，这是打包。

3. loader：文件转换器。例如把es6转为es5，scss转为css等

4. plugin：扩展webpack功能的插件。在webpack构建的生命周期节点上加入扩展hook，添加功能。

## 9.2 webpack构建流程（原理）

从启动构建到输出结果一系列过程：

1. 初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。

2. 开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。

3. 确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。

4. 编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。

5. 完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。

6. 输出完成：输出所有的chunk到文件系统。

注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。