# 1.浏览器篇
## 1.1 常用那几种浏览器测试？主流浏览器的内核有哪些？
1. **Trident内核**：代表产品为**Internet Explorer**，又称其为IE内核。Trident（又称为MSHTML），是微软开发的一种排版引擎；
2. **Webkit内核**：代表作品有Safari、Chrome。WebKit是一个开源项目，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示；
3. **Gecko内核**： **Netscape6**开始采用的内核，后来的**Mozilla FireFox** (火狐浏览器) 也采用了该内核，K-Meleon浏览器也是使用这种内核,Gecko是一套开放源代码的、以C++编写的网页排版引擎；
4. **Presto内核**：目前只有**Opera浏览器**采用该内核此外，Presto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。

## 1.2 说说你对浏览器内核的理解？
浏览器内核主要分成两个部分：**渲染引擎**和**JS引擎**。
**渲染引擎**：负责取得网页内容（html，xml和图像等），整理讯息（e.g.css），以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，因此，渲染效果也不同。所有网页浏览器、电子邮件客户端以及需要编辑显示网络内容的应用程序都需要内核。
**JS引擎**：解析和执行JavaScript来实现网页的动态效果，JavaScript的渲染速度越快，动态网页的展示也越快。

## 1.3 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？
1. 浏览器根据请求的URL交给DNS域名解析，找到IP地址；
2. 浏览器根据IP地址向服务器发起TCP连接，三次握手，与服务器建立TCP连接；
   1. 客户端向服务器发送一个建立连接的请求
   2. 服务器接到请求后发送同意连接的信号
   3. 客户端接到同意连接的信号后，再次向服务器发送了确认信号，然后客户端与服务器的连接建立成功
3. 浏览器发送HTTP请求：浏览器根据URL内容生成HTTP请求，请求中包含请求文件的位置、请求文件的方式等等；
4. 服务器处理请求并返回HTTP报文（HTTP响应报文由三部分组成：状态码、响应报头和响应报文）
   1. 服务器接到请求后，根据HTTP请求中的内容来决定如何获取相应的HTML文件；
   2. 服务器将得到的HTML文件发送给浏览器；
   3. 在浏览器还没有完全接收HTML文件时便开始渲染、显示网页；
   4. 在执行HTML中代码时，根据需要，浏览器会继续请求图片、CSS和JavaScript等文件，过程同HTML。
5. 断开连接。

## 1.4 浏览器缓存
1. sessionStorage
优点：可以临时存储，关闭页面标签自动回收，不支持跨页面交互
缺点：只能作为临时存储，不能存储持久化
2. localStorage
优点：用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。
缺点：存在大小限制，IE8以上的IE版本才支持这个属性；目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换
3. cookie
优点：兼容性最好，几乎所有的浏览器都支持
缺点：大小有限制，而且每次发送请求，请求头里会带着cookie一起发过去，现在基本大多数登录的合法性验证都是用cookie验证的
4. userData
优点：出现的时间比sessionStorage要早
缺点：IE专门的存储方式，存储大小有限，单个文件的大小限制是128KB，一个域名下总共可以保存1024KB的文件，文件个数应该没有限制。在受限站点里这两个值分别是64KB和640KB
## 1.5. HTTP
### 1.5.1 HTTP状态码++
1. 以`2xx`开头的都表示请求成功响应
   
| 状态码 | 含义                                                    |
| ------ | ------------------------------------------------------- |
| 200    | 请求成功                                                |
| 204    | 请求处理成功，但是没有资源可以返回                      |
| 206    | 对资源一部分进行响应，由Content-Range指定范围的实体内容 |

2. 以`3xx`开头的都表示需要进行附加操作以完成请求
   
| 状态码 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 301    | 永久性重定向，该状态码表示请求的资源已经重新分配URI，以后应该使用资源现有的URI |
| 302    | 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问 |
| 303    | 该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源 |
| 304    | 该状态码表示客户端发送附带条件的请求时，服务器允许请求访问资源，但未满足条件的情况 |
| 307    | 临时重定向。该状态码与302 Found有着相同的含义                |

3. 以`4xx`的响应结果表明客户端是发生错误的原因所在。

| 状态码 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 400    | 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。 |
| 401    | 该状态码表示发送的请求需要通过有HTTP认证（BASIC认证、DIGEST认证）的认证信息。 |
| 403    | 该状态码表明对请求资源的访问被服务器拒绝了                   |
| 404    | 该状态码表明服务器上无法找到请求的资源                       |

4. 以`5xx`为开头的响应标头都表示服务器本身发生错误。

| 状态码 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 500    | 该状态码表明服务器端在执行请求时发生了错误。                 |
| 503    | 该状态码表明服务器暂时处于超负载状态或正在停机维护，现在无法处理请求 |

### 1.5.2 URL和URI有什么区别？
**URI = Universal Resource Identifier** 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。
**URL = Universal Resource Locator** 统一资源定位符，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol、host、port、path、parameter、anchor。
**URN = Universal Resource Name** 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。

URI 是用来唯一标识资源， URL 提供资源的识别方法并用着各种方法定位资源。

由于互联网上每个文件都有唯一的URL, 所以URL是一种具体的URI， 可以说URL是URI的一种实现方式。

### 1.5.3 HTTP和HTTPS+

#### HTTP

[超文本传输协议](https://baike.baidu.com/item/超文本传输协议/8535513)（HTTP，HyperText Transfer Protocol)是[互联网](https://baike.baidu.com/item/互联网)上应用最为广泛的一种[网络协议](https://baike.baidu.com/item/网络协议/328636)。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。

**HTTP原理**

1. 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。

2. 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。

#### HTTPS

是以安全为目标的 HTTP 通道，是 **HTTP 的安全版**。HTTPS 的安全基础是 **SSL**（Secure Socket Layer，安全套接字层）。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

**HTTPS设计目标：**

1. 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么 。

2. 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。

3. 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 。

#### HTTP 与 HTTPS的区别

1. HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。

2. HTTP 是超文本传输协议，信息是**明文传输**，HTTPS 则是具有安全性的 **SSL 加密传输**协议。

3. HTTP 和 HTTPS 使用的是完全不同的连接方式，用的**端口也不一样**，前者是**80**，后者是**443**。

4. HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

#### HTTPS相对于HTTP的改进

**双向的身份认证**

客户端和服务端在传输数据之前,会通过基于X.509证书对双方进行身份认证 。具体过程如下：

1. 客户端发起 SSL 握手消息给服务端要求连接。

2. 服务端将证书发送给客户端。

3. 客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。

4. 服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的[公钥](https://baike.baidu.com/item/公钥/6447788)，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。

**数据传输的机密性**

客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。

**防止重放攻击**

SSL 使用序列号来保护通讯方免受报文重放攻击。

#### HTTPS的优缺点

**优点**

1. 使用 HTTPS 协议可认证用户和服务器，**确保数据发送**到正确的客户机和服务器。

2. HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议**安全**，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它**大幅增加了中间人攻击的成本**。

**缺点**

1. HTTPS 协议**握手阶段比较费时**，会使页面的加载时间延长近。

2. HTTPS **连接缓存不如 HTTP 高效**，会**增加数据开销**，甚至已有的安全措施也会因此而受到影响。

3. HTTPS 协议的**安全是有范围的**，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。

4. **SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名**，IPv4 资源不可能支撑这个消耗。

5. **成本增加**。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。

6. HTTPS 协议的**加密范围也比较有限**。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。

#### HTTPS握手+

1. 客户端的浏览器向服务器发送请求，并传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。
2. 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端**传送自己的证书**。
3. 客户端利用服务器传过来的信息**验证服务器的合法性**，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 "发行者的数字签名"，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。
4. 用户端**随机产生一个用于通讯的 "对称密码"**，然后用服务器的公钥（服务器的公钥从步骤2中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。
5. 如果**服务器要求客户的身份认证**（在握手过程中为可选），**用户可以建立一个随机数然后对其进行数据签名**，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。
6. 如果**服务器要求客户的身份认证**，**服务器必须检验客户证书和签名随机数的合法性**，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA 是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。
7. **服务器和客户端用相同的对称加密密钥**，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。
8. **客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤7中的主密码为对称密钥**，同时**通知服务器客户端的握手过程结束**。
9.  **服务器向客户端发出信息，指明后面的数据通讯将使用的步骤7中的主密码为对称密钥**，同时**通知客户端服务器端的握手过程结束**。
10. **SSL 的握手部分结束**，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。

![HTTPS握手](https://img-blog.csdn.net/20180709141944471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

# 2.HTML篇

## 2.1 Doctype
`\<!DOCTYPE>`声明位于位于HTML文档中的第一行，处于`\<html>`标签之前。

### 2.1.1 作用
告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE**不存在或格式不正确**会导致文档以**兼容模式**呈现。

### 2.1.2 标准模式和兼容模式各有什么区别
标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。
在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。
简单的说，就是尽可能的显示能显示的东西给用户看。

**具体的说：**

1. **width不同**
   在严格模式中 ：width是内容宽度 ，元素真正的宽度 = margin-left + border-left-width + padding-left + width + padding-right + border-right- width + margin-right;
   在兼容模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( padding-left + padding-right + border-left-width + border-right-width)

2. 兼容模式下可设置**百分比的高度和行内元素的高宽**
     在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。
     在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。

3. 用margin:0 auto设置水平居中在IE下会失效
     使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决）
     body{text-align:center};#content{text-align:left}

4. 兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效

### 2.1.3 为什么H5只需要写\<!DOCTYPE>

- HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）
- 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型

### 2.1.4 常见的DOCTYPE 声明

**HTML 5**

```html
\<!DOCTYPE html>
```

**HTML 4.01 Strict**
该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```html
\<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

**HTML 4.01 Transitional**
该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```
\<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
```

**HTML 4.01 Frameset**
该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。

```html
\<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN""http://www.w3.org/TR/html4/frameset.dtd">
```

**XHTML 1.0 Strict**

该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```html
\<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

**XHTML 1.0 Transitional**

该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```html
\<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

**XHTML 1.0 Frameset**

该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。

```html
\<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
```

**XHTML 1.1**

该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。

```html
\<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
```

## 2.2 说说你对语义化的理解？

### 2.2.1 什么是HTML语义化？

根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。

### 2.2.2 为什么要语义化

1. 为了在没有CSS的情况下，页面也能呈现出很好地内容结构及代码结构；
2. 利于SEO搜索引擎优化，和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重；
3. 方便浏览器和其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
4. 提高代码的可维护和可重用性。

### 2.2.3 语义化注意事项

1. 尽可能**少的使用**无语义的标签**div和span**；
2. 在语义不明显时，**既可以使用div或者p时，尽量用p**, 因为p在默认情况下有**上下间距**，对兼容特殊终端有利；
3. **不要使用纯样式标签**，如：b、font、u等，改用css设置。
4. 需要**强调的文本，可以包含在strong或者em标签中**（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；
5. 使用**表格时，标题要用caption，表头用thead，主体部分用tbody包围**，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；
6. **表单域要用fieldset**标签包起来，并用**legend标签说明表单的用途**；
7. **每个input标签对应的说明文本都需要使用label标签**，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。

## 2.3 HTML与XHTML有什么区别?

**最主要的不同：**

- XHTML 元素必须被正确地嵌套。
- XHTML 元素必须被关闭。
- 标签名必须用小写字母。
- XHTML 文档必须拥有根元素。
- XHTML对于图片需添加alt属性

## 2.4 页面导入样式时，使用link和@import有什么区别？

### 2.4.1 import的写法

```
\<style type=”text/css”>
	@import url（“a.css”）；
\</style>
```

### 2.4.2 link的写法

```
\<link rel="stylesheet" href="index.css">
```

### 2.4.3 两者区别

1. **来源**：link属于XHTML标签，import是CSS提供的方式。**link方式除了CSS，还可以定义RSS，定义rel连接属性等，而import只能加载CSS**。
2. **顺序**：**link是页面加载时同时执行的，而import是在页面加载完之后，才会执行的**（所以容易导致样式闪烁，即开始页面没有样式，突然会闪烁一下，然后就有了样式，就我个人比较喜欢link引用的方式）
3. **js控制的差别**：当页面需要使用javascript控制dom改变样式的时候，只能使用link标签，因为import不是js操作dom可以控制的。也不支持js操作dom来控制。

## 2.5 HTML5有哪些新特性？+

1. 语义化标签
2. 增强型表单
3. 新增视频<video>和音频<audio>标签
4. Canvas&SVG绘图
5. 地理定位API
6. 拖放API
7. Web Worker
8. Web Storage
9. WebSocket

### 2.5.1 h5新语义/结构元素

| 标签          | 描述                                                 |
| :------------ | :--------------------------------------------------- |
| \<article>    | 定义文档内的文章。                                   |
| \<aside>      | 定义页面内容之外的内容。                             |
| \<bdi>        | 定义与其他文本不同的文本方向。                       |
| \<details>    | 定义用户可查看或隐藏的额外细节。                     |
| \<dialog>     | 定义对话框或窗口。                                   |
| \<figcaption> | 定义 \<figure> 元素的标题。                          |
| \<figure>     | 定义自包含内容，比如图示、图表、照片、代码清单等等。 |
| \<footer>     | 定义文档或节的页脚。                                 |
| \<header>     | 定义文档或节的页眉。                                 |
| \<hgroup>     | 用于对网页或区段（section）的标题进行组合。          |
| \<main>       | 定义文档的主内容。                                   |
| \<mark>       | 定义重要或强调的内容。                               |
| \<menuitem>   | 定义用户能够从弹出菜单调用的命令/菜单项目。          |
| \<meter>      | 定义已知范围（尺度）内的标量测量。                   |
| \<nav>        | 定义文档内的导航链接。                               |
| \<progress>   | 定义任务进度。                                       |
| \<rp>         | 定义在不支持 ruby 注释的浏览器中显示什么。           |
| \<rt>         | 定义关于字符的解释/发音（用于东亚字体）。            |
| \<ruby>       | 定义 ruby 注释（用于东亚字体）。                     |
| \<section>    | 定义文档中的节。                                     |
| \<summary>    | 定义 \<details> 元素的可见标题。                     |
| \<time>       | 定义日期/时间。                                      |
| \<wbr\>       | 定义可能的折行（line-break）。                       |

总体来说，这些标签就是div标签的语义化转化，过去我们曾用div来包裹某个块或者说组件，现在h5使用这些标签实现语义化，有利于代码可读性和SEO。语义元素在IE6-8的兼容可以使用。

#### H5删除的元素

| 删除的元素                                                   | 替代方法        |
| ------------------------------------------------------------ | --------------- |
| <acronym> 首字母缩写                                         | <abbr>          |
| <applet>                                                     | <object>        |
| <basefont> 页面上默认字体颜色和字号                          | css             |
| <big> 更大的文本                                             | css             |
| <center> 文本水平居中                                        | css             |
| <dir> 目录列表                                               | css             |
| <font> 字体外观，尺寸，颜色                                  | css             |
| <frame> 定义子窗口                                           |                 |
| <frameset> 定义框架集                                        |                 |
| <noframes> 向浏览器显示无法处理框架的提示文本，位于frameset元素中 |                 |
| <strike> 文本添加删除线                                      | css或<s>或<del> |
| <tt> 定义打字机文本                                          | css             |



### 2.5.2 增强型input

#### 新增表单元素

| 标签        | 描述                             |
| :---------- | :------------------------------- |
| \<datalist> | 定义输入控件的预定义选项。       |
| \<keygen>   | 定义键对生成器字段（用于表单）。 |
| \<output>   | 定义计算结果。                   |



#### 新增输入类型和输入属性

| 新的输入类型   | 说明                                                         | 新的输入属性     | 说明                                                         |
| -------------- | ------------------------------------------------------------ | ---------------- | ------------------------------------------------------------ |
| color          | 用于应该包含颜色的输入字段。（颜色选择器）                   | autocomplete     | 属性规定表单或输入字段是否应该自动完成。（on\|off）          |
| date           | 用于应该包含日期的输入字段。                                 | autofocus        | 规定当页面加载时 \<input> 元素应该自动获得焦点。             |
| datetime       | 允许用户选择日期和时间（有时区）。(Chrome、FF、IE不支持)     | form             | 规定 \<input> 元素所属的一个或多个表单。 （空格分隔）        |
| datetime-local | 允许用户选择日期和时间（无时区）。（FF、IE不支持）           | formaction       | 规定当提交表单时处理该输入控件的文件的 URL。                 |
| email          | 用于应该包含电子邮件地址的输入字段。                         | formenctype      | 规定当把表单数据（form-data）提交至服务器时如何对其进行编码（仅针对 method="post" 的表单）。 |
| month          | 允许用户选择**月份和年份**。                                 | formmethod       | 定义用以向 action URL 发送表单数据（form-data）的 HTTP 方法。 |
| number         | 用于应该包含数字值的输入字段。                               | formnovalidate   | 规定在提交表单时不对 \<input> 元素进行验证。【额外提交】     |
| range          | 用于应该包含一定范围内的值的输入字段。（部分浏览器显示为滑块） | formtarget       | 规定的名称或关键词指示提交表单后在何处显示接收到的响应。     |
| search         | 用于搜索字段（搜索字段的表现类似常规文本字段）。             | height&width     | 规定 \<input> 元素的高度和宽度。                             |
| tel            | 用于应该包含电话号码的输入字段。（只有 Safari 8 支持 tel 类型。） | list             | list 属性引用的 \<datalist> 元素中包含了 \<input> 元素的预定义选项。 |
| time           | 允许用户选择时间（无时区）。                                 | min&max          | 规定 \<input> 元素的最小值和最大值。                         |
| url            | 用于应该包含 URL 地址的输入字段。自动验证。（IE9及之前不支持） | multiple         | 规定允许用户在 \<input> 元素中输入一个以上的值。             |
| week           | 允许用户选择周和年。                                         | novalidate       | 规定在提交表单时不对表单数据进行验证。                       |
|                |                                                              | pattern (regexp) | 规定用于检查 \<input> 元素值的正则表达式。                   |
|                |                                                              | placeholder      | 规定用以描述输入字段预期值的提示（样本值或有关格式的简短描述）。 |
|                |                                                              | required         | 规定在提交表单之前必须填写输入字段。                         |
|                |                                                              | step             | 规定 \<input> 元素的合法数字间隔。                           |



### 2.5.3 新增视频\<video>和音频\<audio>标签

| **标签**     | **描述**                                               |
| :----------- | :----------------------------------------------------- |
| **\<audio>** | 定义声音或音乐内容。                                   |
| <embed>      | 定义外部应用程序的容器（比如插件）。                   |
| <source>     | 定义 <video> 和 <audio> 的来源。                       |
| <track>      | 定义 <video> 和 <audio> 的轨道。（主流浏览器都不支持） |
| **\<video>** | 定义视频或影片内容。                                   |



### 2.5.4 新的图形标签

| 标签     | 描述                             |
| :------- | :------------------------------- |
| <canvas> | 定义使用 JavaScript 的图像绘制。 |
| <svg>    | 定义使用 SVG 的图像绘制。        |



#### SVG和Canvas的区别

- SVG 是一种使用 XML 描述 2D 图形的语言。

- Canvas 通过 JavaScript 来绘制 2D 图形。

- SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。

- 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

- Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。



### 2.5.5 地理定位

```pseudocode
window.navigator.geolocation {
    getCurrentPosition:  fn  用于获取当前的位置数据
    watchPosition: fn  监视用户位置的改变
    clearWatch: fn  清除定位监视
}
```



### 2.5.6 拖放API

**拖动的源对象(source)可能触发的事件：**

- dragstart：拖动开始

- drag：拖动中

- dragend：拖动结束

**拖动的目标对象(target)可能触发的事件：**

- dragenter：拖动进入

- dragover：拖动悬停

- drop：松手释放

- dragleave：拖动离开

拖放API事件句柄中所有的事件对象都有一个dataTransfer属性（数据运输对象），用于在源对象和目标对象间传递数据。

**源对象**：event.dataTransfer.setData(key, value)

**目标对象**：var value = event.dataTransfer.getData(key)



### 2.5.7 WebWorker

Chrome浏览器中发起资源请求的有6个线程；但是只有1个线程负责渲染页面——称为UI主线程——浏览器中所有的代码只能由一个线程来执行。若浏览器加载了一个很耗时的JS文件(可能影响DOM树结构)，浏览器必须等待该文件执行完成才会继续执行后续的代码。执行耗时JS任务过程中，会暂停页面中一切内容的渲染以及事件的处理。



**Worker的本质**：就是一个执行指定任务的独立线程；且该线程可以与UI主线程进行消息数据传递。

**HTML文件中：**

```js
var w = new Worker('js/x.js')
w.postMessage('发送给Worker线程的消息');
w.onmessage = function(e){
	e.data; //来自Worker线程的消息
}
```

**JS文件中：**

```js
onmessage = function(e){
	var data = e.data;  //接收UI线程的消息
	//执行耗时任务....
	postMessage(result);  //给UI线程发送消息
}
```

**注意：**Worker任务不允许直接操作DOM树，也不允许使用任何的BOM对象！需要的数据只能由UI主线程来传递，处理的结果也必须交由UI线程来显示。



### 2.5.8 WebStorage

#### Web存储结构

1. **服务器端存储**
   1. 数据库存储，如商品、用户等核心数据
   2. Session/内存存储，如用户的登录信息
2. 客户端存储
   1. Cookie存储，如用户偏好、访问历史，浏览器兼容性好但处理麻烦且容量限制
   2. H5 WebStorage存储，如用户偏好、访问历史等安全要求的数据，老IE不兼容但易使用且容量大

#### H5中的WebStorage

1. sessionStorage：类数组对象，通过key=>value对存储字符串数据——会话级存储
2. localStorage：类数组对象，通过key=>value对存储字符串数据——本地/跨会话级/永久存储

#### cookies、sessionStorage、localStora的区别

| 不同点         | 存储大小 | 有效时间                                                     | 数据与服务器交互方式                                         |
| -------------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| cookies        | <=4K     | 在设置cookie过期之前一直有效（无论窗口浏览器是否关闭）       | 正常情况下，cookies数据会自动传到服务器，服务器也可以写cookie到客户端 |
| sessionstorage | 5M       | 数据在当前浏览器关闭后删除（sessionStorage与存储数据的顶级窗口或浏览器选项卡具有相同的生命周期。） | 不会发送数据到服务端                                         |
| localstorage   | 5M       | 持久存储，浏览器关闭后不会丢失除非主动删除（直到Web应用程序删除它或用户要求浏览器删除它） | 不会发送数据到服务端                                         |

### 2.5.9 WebSocket

WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。

WebSocket 使得客户端和服务器之间的数据交换变得更加简单，**允许服务端主动向客户端推送数据**。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

## 2.6 iframe的优缺点？

### 2.6.1 优点

1. 能顾原封不动地把嵌入的网页展现出来；
2. 如果有多个网页引用iframe，那么仅需修改iframe的内容，就可以实现调用的每一个页面内容的修改，方便快捷；
3. 网页如果为了统一风格，头部和版本都一样，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用性；
4. 吐过遇到加载缓慢的第三方内容如图标和广告，那么可以由iframe来解决。

### 2.6.2 缺点

1. 会产生很多页面，不容易管理；
2. iframe框架结构有时会让人感到迷惑，如果框架个数多，可能会出现多个上下、左右滚动条，会分散访问者的注意力，用户体验差；
3. 代码复杂，无法被一些搜素引擎索引到，不能被搜索引擎爬虫处理，不利于SEO。
4. 很多移动设备无法完全显示框架，设备兼容性差。
5. iframe框架会增加服务器的http请求，对于大型网站来说不可取。

## 2.7 img中的alt与title属性 

**alt：**在图片无法正确显示的时候起到文本替代的作用

**title：**鼠标滑过时显示的文字提示



# 3. CSS篇

## 3.1 行内元素有哪些？块级元素有哪些？

### 3.1.1 行内元素

- 和其他元素都在一行上；
- 高，行高及外边距和内边距不可改变；
- 宽度就是它的文字或图片的宽度，不可改变；
- 内联元素只能容纳文本或者其他内联元素；
- 对行内元素，需要注意如下：
  - 设置宽度width 无效。
  - 设置高度height 无效，可以通过line-height来设置。
  - 设置margin 只有左右margin有效，上下无效。
  - 设置padding 只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。

**常见行内元素**

| 标签               | 描述                       |
| :----------------- | :------------------------- |
| <a>                | 定义锚。                   |
| <audio>            | 定义音频。                 |
| \<br>              | 定义简单的折行。           |
| <button>           | 定义按钮 (push button)。   |
| <code>             | 定义计算机代码文本。       |
| <i>                | 定义斜体字。               |
| <img>              | 定义图像。                 |
| <input>            | 定义输入控件。             |
| <label>            | 定义 input 元素的标注。    |
| <select>           | 定义选择列表（下拉列表）。 |
| <span>             | 定义文档中的节。           |
| <textarea>         | 定义多行的文本输入控件。   |
| <video>            | 定义视频。                 |
| 其他和文本相关标签 |                            |

### 3.1.2 块级元素

- 总是在新行上开始；
- 高度，行高以及外边距和内边距都可控制；
- 宽度缺省是它的容器的100%，除非设定一个宽度。
- 它可以容纳内联元素和其他块元素

| 标签         | 描述                                       |
| :----------- | :----------------------------------------- |
| <article>    | 定义文章。                                 |
| <aside>      | 定义页面内容之外的内容。                   |
| <canvas>     | 定义图形。                                 |
| <caption>    | 定义表格标题。                             |
| <dd>         | 定义定义列表中项目的描述。                 |
| <div>        | 定义文档中的节。                           |
| <dl>         | 定义定义列表。                             |
| <dt>         | 定义定义列表中的项目。                     |
| <details>    | 定义元素的细节。                           |
| <fieldset>   | 定义围绕表单中元素的边框。                 |
| <figcaption> | 定义 figure 元素的标题。                   |
| <figure>     | 定义媒介内容的分组，以及它们的标题。       |
| <footer>     | 定义 section 或 page 的页脚。              |
| <form>       | 定义供用户输入的 HTML 表单。               |
| <h1> to <h6> | 定义 HTML 标题。                           |
| <header>     | 定义 section 或 page 的页眉。              |
| <hr>         | 定义水平线。                               |
| <legend>     | 定义 fieldset 元素的标题。                 |
| <li>         | 定义列表的项目。                           |
| <menu>       | 定义命令的列表或菜单。                     |
| <meter>      | 定义预定义范围内的度量。                   |
| <nav>        | 定义导航链接。                             |
| <noframes>   | 定义针对不支持框架的用户的替代内容。       |
| <noscript>   | 定义针对不支持客户端脚本的用户的替代内容。 |
| <ol>         | 定义有序列表。                             |
| <output>     | 定义输出的一些类型。                       |
| <p>          | 定义段落。                                 |
| <pre>        | 定义预格式文本。                           |
| <section>    | 定义 section。                             |
| <table>      | 定义表格。                                 |
| <tbody>      | 定义表格中的主体内容。                     |
| <td>         | 定义表格中的单元。                         |
| <tfoot>      | 定义表格中的表注内容（脚注）。             |
| <th>         | 定义表格中的表头单元格。                   |
| <thead>      | 定义表格中的表头内容。                     |
| <time>       | 定义日期/时间。                            |
| <tr>         | 定义表格中的行。                           |
| <ul>         | 定义无序列表。                             |

## 3.2 CSS盒模型

所有HTML元素可以看作盒子，在CSS中，"box model"这一术语是用来设计和布局时使用。CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：**边距，边框，填充，和实际内容**。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。
下面的图片说明了盒子模型(Box Model)：

![CSS盒模型](https://images2018.cnblogs.com/blog/1355903/201805/1355903-20180503195326308-1458795751.png)

盒模型分为两种：**W3c标准的盒子模型（标准盒模型【content-box】）** 、第二种**IE标准的盒子模型（怪异盒模型【border-box】）**

**标准盒模型盒子大小=**content+border+padding+margin

**怪异盒模型盒子大小=****width(content + border + padding) + margin

![标准盒模型](https://img2018.cnblogs.com/blog/1748092/201908/1748092-20190809145641572-714793117.jpg)

![IE盒模型](https://img2018.cnblogs.com/blog/1748092/201908/1748092-20190809145529154-1986045519.jpg)

定义了完整的doctype的标准文档类型，无论是哪种模型情况，最终都会触发标准模式，如果doctype协议缺失，会由浏览器自己界定，在IE浏览器中IE9以下（IE6.IE7.IE8）的版本触发怪异模式，其他浏览器中会默认为W3c标准模式。

**通过属性box-sizing来设置盒子模型的解析模式**

**content-box**： **默认值**，border和padding不算到width范围内，可以理解为是W3c的标准模型(default)

**border-box**：border和padding划归到width范围内，可以理解为是IE的怪异盒模型

**padding-box：**将padding算入width范围

## 3.3 CSS浮动

### 3.3.1 产生原因及现象

一个盒子设置了float属性，导致父级对象盒子不能被撑开。

### 3.3.2 浮动产生的副作用

1. **背景不能显示**：由于浮动产生，如果对父级设置了background，而父级不能被撑开，所以导致背景不能显示。

2. **边框不能撑开**
3. **margin、padding设置值不能正确显示**

### 3.3.3 清除浮动的方式

1. **父级元素定义height**
   原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。
   优点：简单，代码少，容易掌握
   缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题
   建议：不推荐使用，只建议高度固定的布局时使用
   评分：★★☆☆☆
2. **结尾处加空div标签 clear:both**
   原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度
   优点：简单，代码少，浏览器支持好，不容易出现怪问题
   缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不爽
   建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法
   评分：★★★☆☆
3. **父级div定义 伪类:after 和 zoom**
   原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题
   优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）
   缺点：代码多，不少初学者不理解原理，要两句代码结合使用，才能让主流浏览器都支持。
   建议：推荐使用，建议定义公共类，以减少CSS代码。
   评分：★★★★☆
4. **父级div定义 overflow:hidden**
   原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度
   优点：简单，代码少，浏览器支持好
   缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。
   建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。
   评分：★★★☆☆
5. **父级div定义 overflow:auto**
   原理：同4，使用overflow:auto时，浏览器会自动检查浮动区域的高度。
   优点：简单，代码少，浏览器支持好。
   缺点：内部宽高超过父级div时，会出现滚动条。
   建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。

## 3.4 CSS选择符都有哪些？哪些属性可以继承？优先级算法如何计算？

### 3.4.1 选择符有哪些？

#### 通配选择符

\* :{} 匹配所有的元素

#### 类型选择符

p:{} 匹配指定HTML元素

#### 属性选择符

1. input[attr] 选择具有某个属性的元素。

2. input[attr=value] 选择等于具体属性值的元素。

3. input[attr~=value] 根据属性值中的词列表的某个词进行选择。

4. input[attr^="value"] 子串匹配。以value开头。

5. input[attr$="value"] 子串匹配。以value结尾。

6. input[attr*="value"] 子串匹配。包含value。

7. input[attr|=value] 特定属性选择类型。常用于匹配语言。

   ```html
   <style>
   	*[lang|="en"] {color: red;}
   </style>
   <p lang="en">Hello!</p> <!--可以匹配-->
   <p lang="en-us">Greetings!</p> <!--可以匹配-->
   <p lang="en-au">G'day!</p> <!--可以匹配-->
   <p lang="fr">Bonjour!</p> <!--无法匹配-->
   <p lang="cy-en">Jrooana!</p> <!--无法匹配-->
   ```

### 3.4.2 哪些属性可以继承

#### 字体系列属性

**font、font-family、font-weight、font-size、font-style**、font-variant、font-stretch、font-size-adjust

#### 文本系列属性

**color、text-align、line-height**、text-indent、word-spacing、letter-spacing、text-transform、direction

#### 元素可见性

visibility

#### 表格布局属性

caption-side、border-collapse、border-spacing、empty-cells、table-layout

#### 列表属性

list-style-type、list-style-image、list-style-position、list-style

#### 生成内容属性

quotes

#### 光标属性

cursor

#### 页面样式属性

page、page-break-inside、windows、orphans

#### 声音样式属性

speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、azimuth、elevation

## 3.5 CSS3新增伪类有哪些？

1. `:nth-child(n)`选择父元素下的第n个子元素。n可以接受具体的数值，也可以接受函数（如4n-1）。需要注意的是，n是从1开始计算，而不是0。当函数中的n系数为负时，甚至可以达到选择前n个元素的效果。n为odd和even选择奇数偶数元素。

2. `:nth-last-child`倒数计算。

3. `:last-child`最后一个元素。

4. `:only-child`其父元素的唯一元素。

5. `:nth-of-type(n)`父元素下第n个elem元素，n接受的格式和nth-child一样。甚至在绝大多数情况下，nth-of-type的效果甚至和nth-child没有区别，那这两个伪类到底是什么区别呢。

   elem:nth-of-type(n)是“选择父元素下第n个elem元素”。

   而elem:nth-child(n)是“这个伪类选中父元素下的第n个子元素，并且这个子元素的标签名为elem”。

6. `elem:first-of-type`和`elem:last-of-type`选中父元素下第1个/最后一个elem元素。
7. `elem:only-of-type`唯一的elem元素
8. `elem:empty`选择不包含子元素和内容的elem标签。
9. `elem:enabled`和`elem:disabled`可用、禁用状态
10. `elem:checked`匹配每个选中的input元素（适用于单选框和复选框）

## 3.6 如何居中div？

```html
<div id="father">
    <div id="son">
    </div>
</div>
```

### 3.6.1 div行内元素 text-align: center(仅水平)

```css
.father{
    text-align:center;
}

.son{
    display:inline-block;
}
```

### 3.6.2 div块级元素 margin: 0 auto（仅水平）

```css
.son{
    margin:0 auto;
    display:blck;
}
```

### 3.6.3 脱离文档流 绝对定位（水平垂直）

```css
.father{
    position: relative;
}

.son{
    position: absolute;
    top: 50%;
    left: 50%;
    
    width: 10em;
    height: 10em;
    
    margin-top: -5em;
    margin-left: -5em;
}
```

使用calc简化

```css
.son{
    position: absolute;
    top: calc(50% - 5em);
    left: calc(50% - 5em);
    width: 10em;
    height: 10em;
}
```

### 3.6.4 transform变形 （水平垂直）

```css
.son{
    position: absolute;
    top:50%;
    left:50%;
    
    transform: translate(-50%,-50%);
}
```

#### 基于flex布局，全屏（水平垂直）

```css
.father{
    display:flex;
    min-height:100vh;
}
```

#### 基于flex布局，父元素有宽高

```css
.father{
    display:flex;
    align-items:center;
    justfy-content:center;
}
```



## 3.7 为什么要初始化CSS?

1. **浏览器差异**

   因为不同浏览器对标签的默认值不同，如果没对css初始化会出现浏览器之间的页面显示差异

2. **提高编码质量**

   如果不初始化，整个页面做完会很糟糕，重复的css样式很多

## 3.8 说说你对BFC规范的理解？

### 3.8.1 何为BFC

在一个Web页面的CSS渲染中，块级格式化上下文 (Block Fromatting Context)是按照块级盒子布局的。W3C对BFC的定义如下：

浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）

### 3.8.2 创建BFC

- float的值不是none
- position 的值不是static或者relative
- display的值是inline-block,table-cell,flex,table-caption或者inline-flex
- overflow的值不是visible

### 3.8.3 BFC的特性

- 内部的盒子会在垂直方向上一个接一个放置
- 于同一个BFC的两个相邻盒子的margin会重叠
- 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此
- BFC的区域不会与float的元素区域重叠
- 计算BFC的高度时，浮动子元素也参与计算
- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然

### 3.8.4 BFC在布局中的应用

- 要阻止margin重叠，只要将俩个元素放在不同BFC中即可
- 使得父元素包含子元素，常见的方式是为父元素设置overflow：hidden或者浮动父元素。根本原因在于创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题
- 与浮动元素相邻的已生成BFC的元素不能与浮动元素互相覆盖。利用该特性可以作为多栏布局的一种实现方式. 特点在于左右俩栏的宽度固定，中间栏可以根据浏览器宽度自适应

## 3.9 讲讲 position float display 各有哪些取值，它们互相之间会如何影响？

### 3.9.1 position的取值

static(默认)、relative、absolute、fixed、inherit

#### static

始终处于文档流给予的位置。看起来好像没有用，但它可以快速取消定位，让top，right，bottom，left的值失效。在切换的时候可以尝试这个方法。z-index无效（其他才有效)

#### relative和absolute

relative和absolute都可以用于定位，区别在于前者的div还属于正常的文档流，后者已经是脱离了正常文档流，不占据空间位置，不会将父类撑开。定位原点relative是相对于它在正常流中的默认位置偏移，它原本占据的空间仍然保留；absolute相对于第一个position属性值不为static的父类。所以设置了position：absolute，其父类的该属性值要注意，而且overflow：hidden也不能乱设置，因为不属于正常文档流，不会占据父类的高度，也就不会有滚动条。

#### fixed

fixed旧版本IE不支持，却是很有用，定位原点相对于浏览器窗口，而且不能变。常用于header，footer，或者一些固定的悬浮div，随滚动条滚动又稳定又流畅，比JS好多了。fixed可以有很多创造性的布局和作用，兼容性是问题。

#### inherit

position：inherit。规定从父类继承position属性的值，所以这个属性也是有继承性的。IE不支持。

### 3.9.2 float的取值

none（默认）、left、right、inherit。

float：left(或right)，向左（或右）浮动，直到它的边缘碰到包含框或另一个浮动框为止。且脱离普通的文档流，会被正常文档流内的块框忽略。不占据空间，无法将父类元素撑开。

任何元素都可以浮动，浮动元素会生成一个块级框，不论它本身是何种元素。因此，没有必要为浮动元素设置display：block。

如果浮动非替换元素，则要指定一个明确的width，否则它们会尽可能的窄。（什么叫替换元素？根据元素本身的特点定义的， (X)HTML中的img、input、textarea、select、object都是替换元素，这些元素都没有实际的内容。 (X)HTML的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。）

### 3.9.3 position的取值

**none** | **inline** | **block** | **list-item** | **inline-block** | **table** | **inline-table** | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group |run-in |box | inline-box | flexbox | inline-flexbox | **flex** | inline-flex | **gird** | inline-grid | **inherit**

**`none：`隐藏对象。与`visibility`属性的`hidden`值不同，其不为被隐藏的对象保留其物理空间**
**`inline`：指定对象为内联元素。**
**`block`：指定对象为块元素。**
**`list-item`：指定对象为列表项目。**
**`inline-block`：指定对象为内联块元素。（CSS2）**
**`table`：指定对象作为块元素级的表格。类同于html标签`<table>`（CSS2）**
`inline-table`：指定对象作为内联元素级的表格。类同于html标签`<table>`（CSS2）
`table-caption`：指定对象作为表格标题。类同于html标签`<caption>`（CSS2）
`table-cell`：指定对象作为表格单元格。类同于html标签`<td>`（CSS2）
`table-row`：指定对象作为表格行。类同于html标签`<tr>`（CSS2）
`table-row-group`：指定对象作为表格行组。类同于html标签`<tbody>`（CSS2）
`table-column`：指定对象作为表格列。类同于html标签`<col>`（CSS2）
`table-column-group`：指定对象作为表格列组显示。类同于html标签`<colgroup>`（CSS2）
`table-header-group`：指定对象作为表格标题组。类同于html标签`<thead>`（CSS2）
`table-footer-group`：指定对象作为表格脚注组。类同于html标签`<tfoot>`（CSS2）
`run-in`：根据上下文决定对象是内联对象还是块级对象。（CSS3）
`box`：将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）
`inline-box`：将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）
`flexbox`：将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）
`inline-flexbox`：将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）
**`flex`：将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）**
`inline-flex`：将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）
**`grid`：将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局（CSS3）**

### 3.9.4 相互影响

![img](http://img.blog.csdn.net/20170605112137698)

## 3.10 CSS绘制三角形+

### 3.10.1 border实现

![triangle](https://www.mwcxs.top/static/upload/pics/2019/3/29UWmsYL8T8oUqP3A5RBQc7Wf4.png)

```css
#triangle{
    width: 0;
    height: 0;
    border-left:50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
}
```

### 3.10.2 clip-path实现

```css
#triangle{
    width:100px;
    height:100px;
    background: red;
    clip-path:polygon(0,100%,50%,0,100%,100%);
}
```



## 3.11 隐藏元素的八种方法

- visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在
- opacity: 0; CSS3属性，设置0可以使一个元素完全透明
- position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外
- display: none; 元素会变得不可见，并且不会再占用文档的空间。
- transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留
- `<div hidden="hidden">` HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态
- height: 0; 将元素高度设为 0 ，并消除边框
- filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中

# 4. JS篇
## 4.1 面向对象
## 4.2 闭包+++
### 4.2.1 闭包的定义

当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。

### 4.2.2 表现形式

使函数外部能够调用函数内部定义的变量。

### 4.2.3 实例

```js
var count=10;   //全局作用域 标记为flag1
function add(){
    var count=0;    //函数全局作用域 标记为flag2
    return function(){
        count+=1;   //函数的内部作用域
        alert(count);
    }
}
var s = add()
s();//输出1
s();//输出2
```



## 4.3 防抖和节流+

### 4.3.1 防抖
对于短时间内连续触发的事件，防抖的含义就是让某个事件期限内，事件处理函数只执行一次。

**非立即执行版**

```js
function debounce(func, wait) {//非立即执行版
    let timeout;
    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        
        timeout = setTimeout(() => {
            func.apply(context, args);
        }, wait);
    }
}

function scrollTop(){
    console.log("触发了一次");
}

window.onscroll = debounce(scrollTop,1000);//隔1秒后再触发一次
```
**立即执行版**

```js
function debounce(func, wait){//立即执行版
    let timeout;
    return function(){
        let context = this;
        let args = arguments;
        if(timeout) clearTimeout(timeout);
        
        let callNow = !timeout;
        timeout = setTimeout(()=>{
            timeout = null;
        }, wait);
        if(callNow) func.apply(context,args);
    }
}

function scrollTop(){
    console.log("触发了一次");
}

window.onscroll = debounce(scrollTop,1000);//每隔1秒触发一次
```



**组合版**：

```js
/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */
function debounce(func,wait,immediate) {
    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(() => {
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args);
            }, wait);
        }
    }
}
```



### 4.3.2 节流

**所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。**节流会稀释函数的执行频率。对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。

**时间戳版**：

```js
function throttle(func, wait) {
    let previous = 0;
    return function() {
        let now = Date.now();
        let context = this;
        let args = arguments;
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
```



**定时器版**：

```jsx
function throttle(func, wait){
    let timeout;
    return function(){
        let context = this;
        let args = arguments;
        if(!timeout){
            timeout = setTimeout(()=>{
                timeout = null;
                func.apply(context, args);
            }, wait);
        }
    }
}
```

**组合版**：

```jsx
/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */
function throttle(func, wait ,type) {
    if(type===1){
        let previous = 0;
    }else if(type===2){
        let timeout;
    }
    return function() {
        let context = this;
        let args = arguments;
        if(type===1){
            let now = Date.now();

            if (now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        }else if(type===2){
            if (!timeout) {
                timeout = setTimeout(() => {
                    timeout = null;
                    func.apply(context, args)
                }, wait)
            }
        }
    }
}
```



## 4.3 继承++

面向对象的基本特征有：封闭、继承、多态。

在JavaScript中实现继承的方法：

1. 原型链（prototype chaining）

2. call()/apply()

3. 混合方式(prototype和call()/apply()结合)

4. 对象冒充

### 4.3.1 prototype方法

```js
function car(price){
    this.price = price;
}
car.prototype.sayPrice = function(){
    console.log("Price is "+this.price);
}
var oCar = new car("100W");
oCar.sayPrice();
 
function toyCar(price){
    this.price = price;
}
toyCar.prototype = new car();
var oCar2 = new toyCar("10CNY");
oCar2.sayPrice();
```



### 4.3.2 call()/apply()方法

```js
function useCall(a,b){
  this.a = a;
  this.b = b;
  this.say = function(){
      console.log("I'm "+this.a+" You're "+this.b);
  }
 }
 function callThefunction (){
    var args = arguments;
    useCall.call(this,args[0],args[1]);
   // useCall.apply(this,arguments);
  }
var testCall1 = new useCall("Not YY","Not TT");
testCall1.say();
 
var testCall2 = new callThefunction("YY","TT");
testCall2.say();

//  I'm Not YY You're Not TT
//  I'm YY You're TT
```



### 4.3.3 混合方法

```js
//line=readline()
//print(line)

var Person = function(name,age){
    this.name = name;
    this.age = age;
}

var Employee = function(name,age,id){
    this.id = id;
    Person.call(this,name,age);
}

Employee.prototype = new Person();

var employee = new Employee("Jack", 20, 1);
console.log(employee.name);
console.log(employee instanceof Employee);

console.log(employee instanceof Person);
```



### 4.3.4 对象冒充

```js
function Person(name,age){
   this.name = name;
   this.age = age;
   this.show = function(){
       console.log(this.name+",  "+this.age);
   }
}
Person.prototype.sayHi = function(){
   alert('hi');
}
 
function Student(name,age){ 
   this.student = Person;   //将Person类的构造函数赋值给this.student
   this.student(name,age);  //js中实际上是通过对象冒充来实现继承的
   delete this.student;    //移除对Person的引用
}
 
var s = new Student("小明",17);
s.show();
 
var p = new Person("小花",18);
p.show();
// 小明,  17
// 小花,  18
```



4.4 DOM操作（添加、移除、移动、复制、创建和查找节点）
4.5 new 操作符
4.6 HTML5离线存储
4.7 JS的数据类型
4.8 null和undefined的区别
4.9 call()和apply()的区别
4.10 深拷贝和浅拷贝
4.11 ajax
4.12 数组去重
4.13 this对象
4.14 eval()
4.15 什么是UA?
4.16 什么是事件委托？

## 4.17 promise+



4.18 window.onload和document.ready的区别？哪一个先执行？

## 4.19 var、let和const有什么区别+

4.20 JavaScript 启动后，内存中有多少个对象？如何用代码来获得这些信息？

4.21 JavaScript事件执行机制？宏任务、微任务

5. 前端安全问题
     5.1 XSS
       5.2 CSRF

6. 跨域
     6.1 什么是跨域？
       6.2 什么是同源策略？
       6.3 解决跨域的方法有哪些？

7. 性能优化
    7.1 你都用过那种性能优化的方法？
    7.2 CSS Sprite是什么，谈谈这个技术的优缺点

# 8. Vue.js

## 8.1 Vue如何实现双向绑定+

Vue采用数据劫持结合发布者-订阅者模式的方法，通过**Object.defineProperty()**来劫持各个属性的setter,getter属性，在数据变动话，通知订阅者，触发更新回调函数，重新渲染视图.

![vue双向绑定](https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225458132-1434604303.png)

### 8.1.1 Vue3中的变化

使用es2015中的Proxy替代object.defineProperty