# 1.浏览器篇
## 1.1 常用那几种浏览器测试？主流浏览器的内核有哪些？
1. **Trident内核**：代表产品为**Internet Explorer**，又称其为IE内核。Trident（又称为MSHTML），是微软开发的一种排版引擎；
2. **Webkit内核**：代表作品有Safari、Chrome。WebKit是一个开源项目，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示；
3. **Gecko内核**： **Netscape6**开始采用的内核，后来的**Mozilla FireFox** (火狐浏览器) 也采用了该内核，K-Meleon浏览器也是使用这种内核,Gecko是一套开放源代码的、以C++编写的网页排版引擎；
4. **Presto内核**：目前只有**Opera浏览器**采用该内核此外，Presto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。

## 1.2 说说你对浏览器内核的理解？
浏览器内核主要分成两个部分：**渲染引擎**和**JS引擎**。
**渲染引擎**：负责取得网页内容（html，xml和图像等），整理讯息（e.g.css），以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，因此，渲染效果也不同。所有网页浏览器、电子邮件客户端以及需要编辑显示网络内容的应用程序都需要内核。
**JS引擎**：解析和执行JavaScript来实现网页的动态效果，JavaScript的渲染速度越快，动态网页的展示也越快。

## 1.3 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？
1. 浏览器根据请求的URL交给DNS域名解析，找到IP地址；
2. 浏览器根据IP地址向服务器发起TCP连接，三次握手，与服务器建立TCP连接；
   1. 客户端向服务器发送一个建立连接的请求
   2. 服务器接到请求后发送同意连接的信号
   3. 客户端接到同意连接的信号后，再次向服务器发送了确认信号，然后客户端与服务器的连接建立成功
3. 浏览器发送HTTP请求：浏览器根据URL内容生成HTTP请求，请求中包含请求文件的位置、请求文件的方式等等；
4. 服务器处理请求并返回HTTP报文（HTTP响应报文由三部分组成：状态码、响应报头和响应报文）
   1. 服务器接到请求后，根据HTTP请求中的内容来决定如何获取相应的HTML文件；
   2. 服务器将得到的HTML文件发送给浏览器；
   3. 在浏览器还没有完全接收HTML文件时便开始渲染、显示网页；
   4. 在执行HTML中代码时，根据需要，浏览器会继续请求图片、CSS和JavaScript等文件，过程同HTML。
5. 断开连接。

## 1.4 浏览器缓存
1. sessionStorage
优点：可以临时存储，关闭页面标签自动回收，不支持跨页面交互
缺点：只能作为临时存储，不能存储持久化
2. localStorage
优点：用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。
缺点：存在大小限制，IE8以上的IE版本才支持这个属性；目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换
3. cookie
优点：兼容性最好，几乎所有的浏览器都支持
缺点：大小有限制，而且每次发送请求，请求头里会带着cookie一起发过去，现在基本大多数登录的合法性验证都是用cookie验证的
4. userData
优点：出现的时间比sessionStorage要早
缺点：IE专门的存储方式，存储大小有限，单个文件的大小限制是128KB，一个域名下总共可以保存1024KB的文件，文件个数应该没有限制。在受限站点里这两个值分别是64KB和640KB
## 1.5. HTTP
### 1.5.1 http状态码
1. 以`2xx`开头的都表示请求成功响应
   
| 状态码 | 含义                                                    |
| ------ | ------------------------------------------------------- |
| 200    | 请求成功                                                |
| 204    | 请求处理成功，但是没有资源可以返回                      |
| 206    | 对资源一部分进行响应，由Content-Range指定范围的实体内容 |

2. 以`3xx`开头的都表示需要进行附加操作以完成请求
   
| 状态码 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 301    | 永久性重定向，该状态码表示请求的资源已经重新分配URI，以后应该使用资源现有的URI |
| 302    | 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问 |
| 303    | 该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源 |
| 304    | 该状态码表示客户端发送附带条件的请求时，服务器允许请求访问资源，但未满足条件的情况 |
| 307    | 临时重定向。该状态码与302 Found有着相同的含义                |

3. 以`4xx`的响应结果表明客户端是发生错误的原因所在。

| 状态码 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 400    | 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。 |
| 401    | 该状态码表示发送的请求需要通过有HTTP认证（BASIC认证、DIGEST认证）的认证信息。 |
| 403    | 该状态码表明对请求资源的访问被服务器拒绝了                   |
| 404    | 该状态码表明服务器上无法找到请求的资源                       |

4. 以`5xx`为开头的响应标头都表示服务器本身发生错误。

| 状态码 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| 500    | 该状态码表明服务器端在执行请求时发生了错误。                 |
| 503    | 该状态码表明服务器暂时处于超负载状态或正在停机维护，现在无法处理请求 |

### 1.5.2 URL和URI有什么区别？
**URI = Universal Resource Identifier** 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。
**URL = Universal Resource Locator** 统一资源定位符，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol、host、port、path、parameter、anchor。
**URN = Universal Resource Name** 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。

URI 是用来唯一标识资源， URL 提供资源的识别方法并用着各种方法定位资源。

由于互联网上每个文件都有唯一的URL, 所以URL是一种具体的URI， 可以说URL是URI的一种实现方式。

### 1.5.3 HTTP和HTTPS

#### HTTP

[超文本传输协议](https://baike.baidu.com/item/超文本传输协议/8535513)（HTTP，HyperText Transfer Protocol)是[互联网](https://baike.baidu.com/item/互联网)上应用最为广泛的一种[网络协议](https://baike.baidu.com/item/网络协议/328636)。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。

**HTTP原理**

1. 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。

2. 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。

#### HTTPS

是以安全为目标的 HTTP 通道，是 **HTTP 的安全版**。HTTPS 的安全基础是 **SSL**（Secure Socket Layer，安全套接字层）。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

**HTTPS设计目标：**

1. 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么 。

2. 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。

3. 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 。

#### HTTP 与 HTTPS的区别

1. HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。

2. HTTP 是超文本传输协议，信息是**明文传输**，HTTPS 则是具有安全性的 **SSL 加密传输**协议。

3. HTTP 和 HTTPS 使用的是完全不同的连接方式，用的**端口也不一样**，前者是**80**，后者是**443**。

4. HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

#### HTTPS相对于HTTP的改进

**双向的身份认证**

客户端和服务端在传输数据之前,会通过基于X.509证书对双方进行身份认证 。具体过程如下：

1. 客户端发起 SSL 握手消息给服务端要求连接。

2. 服务端将证书发送给客户端。

3. 客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。

4. 服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的[公钥](https://baike.baidu.com/item/公钥/6447788)，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。

**数据传输的机密性**

客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。

**防止重放攻击**

SSL 使用序列号来保护通讯方免受报文重放攻击。

#### HTTPS的优缺点

**优点**

1. 使用 HTTPS 协议可认证用户和服务器，**确保数据发送**到正确的客户机和服务器。

2. HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议**安全**，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它**大幅增加了中间人攻击的成本**。

**缺点**

1. HTTPS 协议**握手阶段比较费时**，会使页面的加载时间延长近。

2. HTTPS **连接缓存不如 HTTP 高效**，会**增加数据开销**，甚至已有的安全措施也会因此而受到影响。

3. HTTPS 协议的**安全是有范围的**，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。

4. **SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名**，IPv4 资源不可能支撑这个消耗。

5. **成本增加**。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。

6. HTTPS 协议的**加密范围也比较有限**。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。

#### HTTPS握手

1. 客户端的浏览器向服务器发送请求，并传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。
2. 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端**传送自己的证书**。
3. 客户端利用服务器传过来的信息**验证服务器的合法性**，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 "发行者的数字签名"，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。
4. 用户端**随机产生一个用于通讯的 "对称密码"**，然后用服务器的公钥（服务器的公钥从步骤2中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。
5. 如果**服务器要求客户的身份认证**（在握手过程中为可选），**用户可以建立一个随机数然后对其进行数据签名**，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。
6. 如果**服务器要求客户的身份认证**，**服务器必须检验客户证书和签名随机数的合法性**，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA 是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。
7. **服务器和客户端用相同的对称加密密钥**，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。
8. **客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤7中的主密码为对称密钥**，同时**通知服务器客户端的握手过程结束**。
9.  **服务器向客户端发出信息，指明后面的数据通讯将使用的步骤7中的主密码为对称密钥**，同时**通知客户端服务器端的握手过程结束**。
10. **SSL 的握手部分结束**，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。

![HTTPS握手](https://img-blog.csdn.net/20180709141944471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

# 2.HTML篇

## 2.1 Doctype
`<!DOCTYPE>`声明位于位于HTML文档中的第一行，处于`<html>`标签之前。

### 2.1.1 作用
告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE**不存在或格式不正确**会导致文档以**兼容模式**呈现。

### 2.1.2 标准模式和兼容模式各有什么区别
标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。
在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。
简单的说，就是尽可能的显示能显示的东西给用户看。

**具体的说：**

1. **width不同**
   在严格模式中 ：width是内容宽度 ，元素真正的宽度 = margin-left + border-left-width + padding-left + width + padding-right + border-right- width + margin-right;
   在兼容模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( padding-left + padding-right + border-left-width + border-right-width)

2. 兼容模式下可设置**百分比的高度和行内元素的高宽**
     在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。
     在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。

3. 用margin:0 auto设置水平居中在IE下会失效
     使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决）
     body{text-align:center};#content{text-align:left}

4. 兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效

### 2.1.3 为什么H5只需要写<!DOCTYPE>

- HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）
- 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型

### 2.1.4 常见的DOCTYPE 声明

**HTML 5**

```html
<!DOCTYPE html>
```

**HTML 4.01 Strict**
该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

**HTML 4.01 Transitional**
该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
```

**HTML 4.01 Frameset**
该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN""http://www.w3.org/TR/html4/frameset.dtd">
```

**XHTML 1.0 Strict**

该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

**XHTML 1.0 Transitional**

该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

**XHTML 1.0 Frameset**

该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
```

**XHTML 1.1**

该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
```

## 2.2 说说你对语义化的理解？

### 2.2.1 什么是HTML语义化？

根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。

### 2.2.2 为什么要语义化

1. 为了在没有CSS的情况下，页面也能呈现出很好地内容结构及代码结构；
2. 利于SEO搜索引擎优化，和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重；
3. 方便浏览器和其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
4. 提高代码的可维护和可重用性。

### 2.2.3 语义化注意事项

1. 尽可能**少的使用**无语义的标签**div和span**；
2. 在语义不明显时，**既可以使用div或者p时，尽量用p**, 因为p在默认情况下有**上下间距**，对兼容特殊终端有利；
3. **不要使用纯样式标签**，如：b、font、u等，改用css设置。
4. 需要**强调的文本，可以包含在strong或者em标签中**（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；
5. 使用**表格时，标题要用caption，表头用thead，主体部分用tbody包围**，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；
6. **表单域要用fieldset**标签包起来，并用**legend标签说明表单的用途**；
7. **每个input标签对应的说明文本都需要使用label标签**，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。

## 2.3 HTML与XHTML有什么区别?



  2.4 页面导入样式时，使用link和@import有什么区别？
  2.5 HTML5有哪些新特性？
  2.6 iframe的优缺点？
  2.7 img中的alt与title属性
  2.8 HTML 的中，如何写一个值为 “a”=‘b’ 的属性值？

# 3. CSS篇

3.1 行内元素有哪些？块级元素有哪些？CSS的盒模型？
  3.2 清除浮动有哪些方式？
  3.3 CSS选择符都有哪些？哪些属性可以继承？优先级算法如何计算？
  3.4 CSS3新增伪类有哪些？
  3.5 如何居中div？
  3.6 为什么要初始化CSS?
  3.7 说说你对BFC规范的理解？
  3.8 讲讲 position float display 各有哪些取值，它们互相之间会如何影响？

## 3.9 CSS绘制三角形

### 3.9.1 border实现

![triangle](https://www.mwcxs.top/static/upload/pics/2019/3/29UWmsYL8T8oUqP3A5RBQc7Wf4.png)

```css
#triangle{
    width: 0;
    height: 0;
    border-left:50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
}
```

### 3.9.2 clip-path实现

```css
#triangle{
    width:100px;
    height:100px;
    background: red;
    clip-path:polygon(0,100%,50%,0,100%,100%);
}
```



# 4. JS篇
## 4.1 面向对象
## 4.2 闭包
### 4.2.1 闭包的定义

当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。

### 4.2.2 表现形式

使函数外部能够调用函数内部定义的变量。

### 4.2.3 实例

```js
var count=10;   //全局作用域 标记为flag1
function add(){
    var count=0;    //函数全局作用域 标记为flag2
    return function(){
        count+=1;   //函数的内部作用域
        alert(count);
    }
}
var s = add()
s();//输出1
s();//输出2
```



## 4.3 防抖和节流

### 4.3.1 防抖
对于短时间内连续触发的事件，防抖的含义就是让某个事件期限内，事件处理函数只执行一次。

**非立即执行版**

```js
function debounce(func, wait) {//非立即执行版
    let timeout;
    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        
        timeout = setTimeout(() => {
            func.apply(context, args);
        }, wait);
    }
}

function scrollTop(){
    console.log("触发了一次");
}

window.onscroll = debounce(scrollTop,1000);//隔1秒后再触发一次
```
**立即执行版**

```js
function debounce(func, wait){//立即执行版
    let timeout;
    return function(){
        let context = this;
        let args = arguments;
        if(timeout) clearTimeout(timeout);
        
        let callNow = !timeout;
        timeout = setTimeout(()=>{
            timeout = null;
        }, wait);
        if(callNow) func.apply(context,args);
    }
}

function scrollTop(){
    console.log("触发了一次");
}

window.onscroll = debounce(scrollTop,1000);//每隔1秒触发一次
```



**组合版**：

```js
/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */
function debounce(func,wait,immediate) {
    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(() => {
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args);
            }, wait);
        }
    }
}
```



### 4.3.2 节流

**所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。**节流会稀释函数的执行频率。对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。

**时间戳版**：

```js
function throttle(func, wait) {
    let previous = 0;
    return function() {
        let now = Date.now();
        let context = this;
        let args = arguments;
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
```



**定时器版**：

```jsx
function throttle(func, wait){
    let timeout;
    return function(){
        let context = this;
        let args = arguments;
        if(!timeout){
            timeout = setTimeout(()=>{
                timeout = null;
                func.apply(context, args);
            }, wait);
        }
    }
}
```

**组合版**：

```jsx
/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */
function throttle(func, wait ,type) {
    if(type===1){
        let previous = 0;
    }else if(type===2){
        let timeout;
    }
    return function() {
        let context = this;
        let args = arguments;
        if(type===1){
            let now = Date.now();

            if (now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        }else if(type===2){
            if (!timeout) {
                timeout = setTimeout(() => {
                    timeout = null;
                    func.apply(context, args)
                }, wait)
            }
        }
    }
}
```



## 4.3 继承

面向对象的基本特征有：封闭、继承、多态。

在JavaScript中实现继承的方法：

1. 原型链（prototype chaining）

2. call()/apply()

3. 混合方式(prototype和call()/apply()结合)

4. 对象冒充

### 4.3.1 prototype方法

```js
function car(price){
    this.price = price;
}
car.prototype.sayPrice = function(){
    console.log("Price is "+this.price);
}
var oCar = new car("100W");
oCar.sayPrice();
 
function toyCar(price){
    this.price = price;
}
toyCar.prototype = new car();
var oCar2 = new toyCar("10CNY");
oCar2.sayPrice();
```



### 4.3.2 call()/apply()方法

```js
function useCall(a,b){
  this.a = a;
  this.b = b;
  this.say = function(){
      console.log("I'm "+this.a+" You're "+this.b);
  }
 }
 function callThefunction (){
    var args = arguments;
    useCall.call(this,args[0],args[1]);
   // useCall.apply(this,arguments);
  }
var testCall1 = new useCall("Not YY","Not TT");
testCall1.say();
 
var testCall2 = new callThefunction("YY","TT");
testCall2.say();

//  I'm Not YY You're Not TT
//  I'm YY You're TT
```



### 4.3.3 混合方法

```js
function house(size,price){
    this.size = size;
    this.price = price;
}
house.prototype.showArea=function (){
    console.log("面积为"+this.size);
}
house.prototype.sayPrice=function (){
    console.log("价钱为"+this.price);
}
 
function maofan(size,price){
    house.call(this,size,price);
}
maofan.prototype = new house();
 
var newmaofan = new maofan("20Square meters ","1000CNY");
newmaofan.showArea();
```



### 4.3.4 对象冒充

```js
function Person(name,age){
   this.name = name;
   this.age = age;
   this.show = function(){
       console.log(this.name+",  "+this.age);
   }
}
Person.prototype.sayHi = function(){
   alert('hi');
}
 
function Student(name,age){ 
   this.student = Person;   //将Person类的构造函数赋值给this.student
   this.student(name,age);  //js中实际上是通过对象冒充来实现继承的
   delete this.student;    //移除对Person的引用
}
 
var s = new Student("小明",17);
s.show();
 
var p = new Person("小花",18);
p.show();
// 小明,  17
// 小花,  18
```



4.4 DOM操作（添加、移除、移动、复制、创建和查找节点）
4.5 new 操作符
4.6 HTML5离线存储
4.7 JS的数据类型
4.8 null和undefined的区别
4.9 call()和apply()的区别
4.10 深拷贝和浅拷贝
4.11 ajax
4.12 数组去重
4.13 this对象
4.14 eval()
4.15 什么是UA?
4.16 什么是事件委托？

## 4.17 promise



4.18 window.onload和document.ready的区别？哪一个先执行？

## 4.19 var、let和const有什么区别

4.20 JavaScript 启动后，内存中有多少个对象？如何用代码来获得这些信息？

5. 前端安全问题
     5.1 XSS
       5.2 CSRF

6. 跨域
     6.1 什么是跨域？
       6.2 什么是同源策略？
       6.3 解决跨域的方法有哪些？

7. 性能优化
    7.1 你都用过那种性能优化的方法？
    7.2 CSS Sprite是什么，谈谈这个技术的优缺点

# 8. Vue.js

## 8.1 Vue如何实现双向绑定

Vue采用数据劫持结合发布者-订阅者模式的方法，通过**Object.defineProperty()**来劫持各个属性的setter,getter属性，在数据变动话，通知订阅者，触发更新回调函数，重新渲染视图.

![vue双向绑定](https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225458132-1434604303.png)

### 8.1.1 Vue3中的变化

使用es2015中的Proxy替代object.defineProperty